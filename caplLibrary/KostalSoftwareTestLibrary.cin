/*@!Encoding:936*/
variables {

  char iniParaCfgPath[100];
  char iniTestStepCfgPath[100];
  //int respOk;
  enum demandResult { 
    timeout = 0, 
    fulfillment = 1 
  };
  
  enum determiningFactor {
    determinedBySignal = 0,
    determinedByHardware = 1
  };
  
  char func[38][100]= {"testValidateTesterConfirmation","signalSetting","signalContSetting","testEnableMsg","testDisableMsg","linActivateSlot","linDeactivateSlot","sendCanUdsDiagChkResp","sendCanKostiaDiagChkResp","sendLinUdsDiagChkResp","sendLinKostiaDiagChkResp","wait","decodeAsciiFromRecDiag","vtSysPwrSupInit","vtSysWithExPwrSupInit","vtSysPwrSupVoltSet","vtSysExPwrSupSet","vtSysPwrSupVoltGet","vtSysPwrSupCurrGet","vtsSetThreshold1_8","vtsSetThreshold9_16","prodPwmOutChk","prodPwmOutRisingEdgeMeas","prodPwmOutKeepTimeMeas","prodPwmOutFallingEdgeMeas","prodPwmOutRiseFallCurveMeas","chFixVoltDOSet","chAOSet","chRamVoltDOSet","prodDIPinStatGet","chPwmOutSet","chLoadConnectStatSet","prodOperWithPinStatImpOnSpecSigChk","prodOperWithPinStatImpOnSpecPwmChk","prodOperWithSigStatImpOnSpecPwmChk","sigDirTwoStatInSet","sigDirMulStatInSet","specStatImpOnSigChk"};
  
  enum digitalLevel { 
    Low = 0, 
    High = 1,
    Floating = 2
  };
  
  enum prodInputStat {
    Inactive = 0,
    Active = 1
  };
  
  enum vt7001MeasureRange {
    all = 0,
    _100uA_1mA = 1,
    _1mA_10mA = 2,
    _10mA_100mA = 3,
    _100mA_1A = 4,
    _1A_10A = 5,
    _10A_100A = 6
  };
  
  enum currentUnit {
    uA = 0,
    mA = 1,
    A = 2
  };
  
  enum connectStat {
    disconnect = 0,
    connect = 1
  };
  
  /*enum vt7001InterConnectionMode {
    supint = 0, 
    sup1 = 1, 
    sup2 = 2, 
    supint_sup1 = 3, 
    supint_sup2 = 4, 
    sup1_supint = 5, 
    sup1_sup2 = 6, 
    sup2_supint = 7, 
    sup2_sup1 = 8, 
    sup_series = 9, 
    sup_parallel = 10
  };
  
  enum vt7001ExPowerInputChannel {
    suply1 = 1, 
    suply2 = 2
  };
  
  enum vt7001OutputChannelNo {
    out1 = 1,
    out2 = 2
  };*/
  
  char noParaPick[1][1][1]={'\0'};
  int routeNum[100]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
}

/*****************ini file data handle***************************/
export int getCfgDataArray (char section[],char keyName[],char cfgDataArray[]) {
  int numOfValsReadIn;
  sysGetVariableString(sysvar::iniParaCfgPath,iniParaCfgPath,100); 
  numOfValsReadIn = getProfileArray(section,keyName,cfgDataArray,elCount(cfgDataArray),iniParaCfgPath);
  return numOfValsReadIn;
}

export int getCfgStrArray (char section[],char keyName[],char cfgStrArray[][]) {//sperated by ','
  char buff[1000];
  int i,row,col;
  sysGetVariableString(sysvar::iniParaCfgPath, iniParaCfgPath, 100);  
  getProfileString(section,keyName,"err",buff,elCount(buff),iniParaCfgPath);
  if (strncmp(buff,"err",4)!=0) {
    i=0;
    row=0;
    col=0;
    while((buff[i]!='\0') && (buff[i]!=';')) {
      if (buff[i]!=',') {
        cfgStrArray[row][col]=buff[i];
        col++;
      }
      else {
        cfgStrArray[row][col]='\0';
        row++;
        col=0;
      }
      i++;
    }
    cfgStrArray[row][col]='\0';
    return row;//return row number = real key stringNum - 1
  }
  else {
    testStepFail("Error","Don't find the key %s in section %s at paraCfg.ini file, Please check the section and key name.",keyName,section);
    return -1001;
  } 
}

export int getCfgFuncArray (char section[],char keyName[],char cfgFuncArray[][][],int paraNum[]) {//para sperated by ',' func separated by '|'
  char buff[1000];
  int i,row,col,funcNum;
  sysGetVariableString(sysvar::iniTestStepCfgPath, iniTestStepCfgPath, 100);
  //testStep("","%s,%s,%s",section,keyName,iniTestStepCfgPath);
  getProfileString(section,keyName,"err",buff,elCount(buff),iniTestStepCfgPath);
  //testStep("","%s",buff);
  if (strncmp(buff,"err",4)!=0) {
    i=0;
    row=0;
    col=0;
    funcNum=0;
    while((buff[i]!='\0') && (buff[i]!=';')) {
      if ((buff[i]!=',') && (buff[i]!='|')){
        cfgFuncArray[funcNum][row][col]=buff[i];
        col++;
      }
      else if (buff[i]=='|') {
        cfgFuncArray[funcNum][row][col]='\0';
        paraNum[funcNum]=row;//return para number for each function
        funcNum++;
        row = 0;
        col = 0;
      }
      else {//buff[i]==','
        cfgFuncArray[funcNum][row][col]='\0';
        row++;
        col=0;
      }
      i++;
    }
    cfgFuncArray[funcNum][row][col]='\0';
    paraNum[funcNum]=row;//record para number for last function
    return funcNum;//return funcNum = real function number - 1
  }
  else {
    //testStepFail("Error","Don't find the key %s in section %s at testStepCfg.ini file. Please check the section and key's name.",keyName,section);
    return -1001;
  } 
}

/****************bin file data handle****************************/
export int64 getDataFromBinFile (char filePath[], qword offsetBytePos, int byteLen) {
  dword fileHandle;
  byte buff[131072];//length = 0x20000
  int64 selData;//8 byte
  int i;
  if (byteLen > 8) {
    testStepFail("Error","parameter input error: byteLen > 8.");
    return -1002;
  }
  else {
    fileHandle = openFileRead(filePath,1);
    if (!fileHandle) {
      testStepFail("Open file","Failed to open file: %s",filePath);
      return -1001;
    }
    else {
      testStepPass("Open file","Success to open file: %s",filePath);
      fileGetBinaryBlock(buff,offsetBytePos + byteLen,fileHandle);
      selData = 0;
      for (i = 0; i < byteLen; i++)
        selData = selData + (((qword)buff[offsetBytePos+i])<<(i*8));
      selData = ((swapQWord(selData))>>((8-byteLen)*8));
      testStepPass("Retrieve subcontent","Retrieve subcontent:0x%llX from binary file.",selData);//show in normal sequence
      if (fileClose(fileHandle) == 1)
        return selData;
      else
        return -1003;
    }
  }
}

/**************************get signal property**************************************/
export void getShortSigNameStr (signal* sig, char shortSigNameStr[]) {
  char sigFullName[100];
  int i,j,flag;
  strncpy(sigFullName,sig.name,elCount(sigFullName));//CAN1::HS2_CAN::VCU1::CF_Vcu_GarSelDisp
  i=0;
  j=0;
  flag=0;
  while (sigFullName[i]!='\0') {
    if (flag == 6) {
      shortSigNameStr[j]=sigFullName[i];
      j++;
    }
    if (sigFullName[i]==':')
      flag++;
    i++; 
  }
  shortSigNameStr[j]='\0';
}

/****************************report record related*********************************/
export void sigStatGet (char sig[]) {
  testStep("get signal status","%s = %1.0f",sig,getSignal(sig));
}

/**************************CAN LIN communication*********************************/
export int signalSetting (char sigName[], float valueBase,int range) {
  float sigVal;
  int64 t0,t1;
  int res;
  sigVal = valueBase + random(range);
  res = setSignal(sigName,sigVal);
  if (res == 0) {//0: Signal exists
    t0 = timeNowInt64();
    testStep("set signal status","Start to set %s = %1.0f.",sigName,sigVal);
    do {
      testWaitForTimeout(1);
      t1 = timeNowInt64();
    } while ((getSignal(sigName)!= sigVal) && (_pow(10,-6)*(t1-t0) < 5000));
    if (_pow(10,-6)*(t1-t0) >= 5000) {
      testStepFail("set signal status","set signal failed within 5s, %s = %1.0f, != %1.0f",sigName,getSignal(sigName),sigVal);
      return -1002;
    }
    else {
      testStepPass("set signal status","set %s = %1.0f successfully after %4.2fms.",sigName,getSignal(sigName),_pow(10,-6)*(t1-t0));
      return 0;
    }
  }
  else {//1: Signal with given name does not exist
    testStepFail("Error","Signal %s does not exist.",sigName);
    return -1001;
  }
}

export int signalContSetting (char sigName[], float startVal, int range, long msGapTime) {
  float sigVal;
  int i,res;
  res = 0;
  for (i = 0;((i < range) && (res==0)); i++) {
    sigVal = startVal + i;
    res = signalSetting(sigName,sigVal,1);//signalSetting error code: -1001,-1002
    if (res == 0) { //signalSetting successfully
      res = wait(msGapTime);
      if (res!=0)
        res = res - 2;
    }
  }
  return res;
}

export int cfgLinMsgAndSend (char serviceType[],char serviceName[],char diagInfo[][],linmessage* sendDiag,linmessage* recDiag) {//serviceType[] gets from section name, serviceName[] gets from key name in ini file
  qword sendMsg;
  int paraNum;
  paraNum = getCfgStrArray(serviceType,serviceName,diagInfo);
  //testStep("","%s,%s,%s,%s,%s,%s,%s",diagInfo[0],diagInfo[1],diagInfo[2],diagInfo[3],diagInfo[4],diagInfo[5],diagInfo[6]);
  if (paraNum!=-1001) {
    sendDiag.id = atol(diagInfo[0]);
    sendDiag.dlc = atol(diagInfo[1]);
    strtoull(diagInfo[2],sendMsg);
    recDiag.id = atol(diagInfo[3]);
    testStep(serviceType,"Start to send %s service request.",serviceName);
    sendDiag.rtr = 1;
    output(sendDiag);//send header
    sendDiag.rtr = 0;
    sendDiag.qword(0) = ((swapQWord(sendMsg))>>((8 - sendDiag.dlc)*8));//send response
    output(sendDiag);
    if (testWaitForMessage(sendDiag.id,1000) == 1) {
      testStep("Diagnostic Request","Send diagnostic request: 0x%llX",sendMsg);
      return 0;//output message successfully 
    }
    else {
      testStepFail("Diagnostic Request","Fail to send diagnostic request(ID = %s). Please check the table id or the cancase cofiguration.",diagInfo[0]);
      return -1002;
    }
  }
  else 
    return -1001;//error section or key name
}

export int cfgCanMsgAndSend (char serviceType[],char serviceName[],char diagInfo[][],message* sendDiag,message* recDiag) {//serviceType[] gets from section name, serviceName[] gets from key name in ini file
  qword sendMsg;
  dword sendMsgId,recMsgId;
  int paraNum;
  paraNum = getCfgStrArray(serviceType,serviceName,diagInfo);
  //testStep("","%s,%s,%s,%s,%s,%s,%s",diagInfo[0],diagInfo[1],diagInfo[2],diagInfo[3],diagInfo[4],diagInfo[5],diagInfo[6]);
  if (paraNum!=-1001) {
    strtoul(diagInfo[0],sendMsgId);
    sendDiag.id = sendMsgId;
    sendDiag.DataLength = atol(diagInfo[1]);
    strtoull(diagInfo[2],sendMsg);
    strtoul(diagInfo[3],recMsgId);
    recDiag.id = recMsgId;
    testStep(serviceType,"Start to send %s service request.",serviceName);
    sendDiag.qword(0) = ((swapQWord(sendMsg))>>((8 - sendDiag.DataLength)*8));//send response
    output(sendDiag);
    if (testWaitForMessage(sendDiag.id,1000) == 1) {
      testStep("Diagnostic Request","Send diagnostic request: 0x%llX",sendMsg);
      return 0;//output message successfully 
    }
    else {
      testStepFail("Diagnostic Request","Fail to send diagnostic request. Please check the cancase cofiguration or the product mode.");
      return -1002;
    }
  }
  else
    return -1001;//error section or key name
}

export int sendCanUdsDiagChkResp (char serviceName[],byte recMsg[]) {//same sequence as trace shows, serviceName[] gets from key name in ini file
  message* sendDiag;
  message* recDiag; 
  qword recCanMsg,chkRecMsgPart;
  char diagInfo[7][100];
  int chkByteLen,offsetBytePos,i,j,k,index,dataByte,stopFlag,errorCode;
  errorCode = cfgCanMsgAndSend("UDS Services",serviceName,diagInfo,sendDiag,recDiag);
  //testStep("","%s,%s,%s,%s,%s,%s,%s",diagInfo[0],diagInfo[1],diagInfo[2],diagInfo[3],diagInfo[4],diagInfo[5],diagInfo[6]);
  if (errorCode == 0) {
    offsetBytePos = atol(diagInfo[4]);
    chkByteLen = atol(diagInfo[5]);
    strtoull(diagInfo[6],chkRecMsgPart);
    index = 0;
    i = 0;
    j = 0;
    do {
      if (testWaitForMessage(recDiag.id,5000) == 1) {
        testGetWaitEventMsgData(recDiag);  
        if (i == 0) {
          if (recDiag.byte(0) == 0x10) {
            dataByte = recDiag.byte(1);
            stopFlag = dataByte - 6;
            j = 2;//get data from byte3
          }
          else {
            dataByte = recDiag.byte(0);
            stopFlag = dataByte - 7;
            j = 1;//get data from byte2
          }
          k = (stopFlag > 0)?8:j+dataByte;
        }
        else {
          j = 1;
          k = (stopFlag - 7 > 0)?8:j+stopFlag;
          stopFlag = stopFlag - 7;
        }
        recCanMsg = swapQWord(recDiag.qword(0));//same sequence as trace shows
        for (;j<k;j++) {
          recMsg[index] = recDiag.byte(j);
          index++;
        }
        if (i == 0) {
          if ((offsetBytePos + chkByteLen) <= 8) {//the first message is enough for confirming if it's the right response.
            if (((recCanMsg << (offsetBytePos*8)) >> ((8-chkByteLen)*8)) == chkRecMsgPart) {
              testStepPass("Diagnostic Response","Get positive response:0x%llX.",recCanMsg);
              errorCode = 0;
            }
            else {
              testStepFail("Diagnostic Response","Get negative response:0x%llX.",recCanMsg);
              errorCode = -10001;//negative response.
            }
          }
          else {
            testStepFail("Error","Fail to check the response, since the parameter input error:(offsetBytePos + chkByteLen) > 8.");
            errorCode = -1004;//fail to check,para input error.
          }
          if (recDiag.byte(0) == 0x10) {
            sendDiag.qword(0) = 0x00000000000030ll;//send response
            output(sendDiag);
            testStep("Diagnostic Request","Send diagnostic request: 0x%llX",swapQWord(sendDiag.qword(0)));
          }
        }
        else 
          testStep("Diagnostic Response","Get response:0x%llX.",recCanMsg);
        i++;
      }
      else {
        testStepFail("Diagnostic Response","No corresponding response(ID = 0x%x).",recDiag.id);
        stopFlag = -1;//No corresponding response.
        errorCode = -1003;//No corresponding response.
      } 
    } while (stopFlag > 0);
    if (errorCode == 0)
      return dataByte;
    else
      return errorCode;
  }
  else 
    return errorCode;
}

export int sendCanKostiaDiagChkResp (char serviceName[],byte recMsg[]) {//same sequence as trace shows,serviceName[] gets from key name in ini file
  message* sendDiag;
  message* recDiag; 
  qword recCanMsg,chkRecMsgPart;
  char diagInfo[7][100];
  int chkByteLen,offsetBytePos,j,index,errorCode;
  errorCode = cfgCanMsgAndSend("Kostia Services",serviceName,diagInfo,sendDiag,recDiag);
  //testStep("","%s,%s,%s,%s,%s,%s,%s",diagInfo[0],diagInfo[1],diagInfo[2],diagInfo[3],diagInfo[4],diagInfo[5],diagInfo[6]);
  if (errorCode == 0) {
    offsetBytePos = atol(diagInfo[4]);
    chkByteLen = atol(diagInfo[5]);
    strtoull(diagInfo[6],chkRecMsgPart);
    index = 0;
    if (testWaitForMessage(recDiag.id,5000) == 1) {
      testGetWaitEventMsgData(recDiag);  
      recCanMsg = swapQWord(recDiag.qword(0));//same sequence as trace shows
      for (j=1;j<8;j++) {
        recMsg[index] = recDiag.byte(j);
        index++;
      }
      if ((offsetBytePos + chkByteLen) <= 8) {
        if (((recCanMsg << (offsetBytePos*8)) >> ((8-chkByteLen)*8)) == chkRecMsgPart) {
          testStepPass("Diagnostic Response","Get positive response:0x%llX.",recCanMsg);
          errorCode = 0;
        }
        else {
          testStepFail("Diagnostic Response","Get negative response:0x%llX.",recCanMsg);
          errorCode = -10001;//negative response.
        }
      }
      else {
        testStepFail("Error","Fail to check the response, since the parameter input error:(offsetBytePos + chkByteLen) > 8.");
        errorCode = -1004;//fail to check,para input error.
      }     
    }
    else {
      testStepFail("Diagnostic Response","No corresponding response(ID = 0x%x).",recDiag.id);
      errorCode = -1003;//No corresponding response.
    } 
      
    if (errorCode == 0)
      return 7;//kostial meaningful databyte length = 7
    else
      return errorCode;
  }
  else 
    return errorCode;
}

export int sendLinUdsDiagChkResp (char serviceName[],byte recMsg[]) {//same sequence as trace shows,serviceName[] gets from key name in ini file
  linmessage* sendDiag;
  linmessage* recDiag;
  qword chkRecMsgPart,recLinMsg;
  char diagInfo[7][100];
  int chkByteLen,offsetBytePos,i,j,k,index,dataByte,stopFlag,errorCode;
  errorCode = cfgLinMsgAndSend ("UDS Services",serviceName,diagInfo,sendDiag,recDiag);
  if (errorCode == 0) {
    offsetBytePos = atol(diagInfo[4]);
    chkByteLen = atol(diagInfo[5]);
    strtoull(diagInfo[6],chkRecMsgPart);
    index = 0;
    i = 0;
    j = 0;
    do {
      recDiag.rtr = 1;
      output(recDiag);
      recDiag.rtr = 0;
      if (testWaitForMessage(recDiag.id,5000) == 1) {
        testGetWaitEventMsgData(recDiag);  
        if (i == 0) {
          if (recDiag.byte(1) == 0x10) {
            dataByte = recDiag.byte(2);
            stopFlag = dataByte - 5;
            j = 3;//get data from byte3
          }
          else {
            dataByte = recDiag.byte(1);
            stopFlag = dataByte - 6;
            j = 2;//get data from byte2
          }
          k = (stopFlag > 0)?8:j+dataByte;
        }
        else {
          j = 2;
          k = (stopFlag - 6 > 0)?8:j+stopFlag;
          stopFlag = stopFlag - 6;
        }
        recLinMsg = swapQWord(recDiag.qword(0));//same sequence as trace shows
        for (;j<k;j++) {
          recMsg[index] = recDiag.byte(j);
          index++;
        }
        if (i == 0) {
          if ((offsetBytePos + chkByteLen) <= 8) {
            if (((recLinMsg << (offsetBytePos*8)) >> ((8-chkByteLen)*8)) == chkRecMsgPart) {
              testStepPass("Diagnostic Response","Get positive response:0x%llX.",recLinMsg);
              errorCode = 0;
            }
            else {
              testStepFail("Diagnostic Response","Get negative response:0x%llX.",recLinMsg);
              errorCode = -10001;//negative response.
            }
          }
          else {
            testStepFail("Error","Fail to check the response, since the parameter input error:(offsetBytePos + chkByteLen) > 8.");
            errorCode = -1004;//fail to check,para input error.
          }
        }
        else 
          testStep("Diagnostic Response","Get response:0x%llX.",recLinMsg);
        i++;
      }
      else {
        testStepFail("Diagnostic Response","No corresponding response.");
        stopFlag = -1;//No corresponding response.
        errorCode = -1003;//No corresponding response.
      } 
    } while (stopFlag > 0);
    if (errorCode == 0)
      return dataByte;
    else
      return errorCode;
  }
  else 
    return errorCode;
}

export int sendLinKostiaDiagChkResp (char serviceName[],byte recMsg[]) {//same sequence as trace shows,serviceName[] gets from key name in ini file
  linmessage* sendDiag;
  linmessage* recDiag;
  qword chkRecMsgPart,recLinMsg;
  char diagInfo[7][100];
  int chkByteLen,offsetBytePos,j,index,errorCode;
  errorCode = cfgLinMsgAndSend ("Kostia Services",serviceName,diagInfo,sendDiag,recDiag);
  if (errorCode == 0) {
    offsetBytePos = atol(diagInfo[4]);
    chkByteLen = atol(diagInfo[5]);
    strtoull(diagInfo[6],chkRecMsgPart);
    index = 0;
    recDiag.rtr = 1;
    output(recDiag);
    recDiag.rtr = 0;
    if (testWaitForMessage(recDiag.id,5000) == 1) {
      testGetWaitEventMsgData(recDiag);  
      recLinMsg = swapQWord(recDiag.qword(0));//same sequence as trace shows
      for (j=1;j<8;j++) {
        recMsg[index] = recDiag.byte(j);
        index++;
      }
      if ((offsetBytePos + chkByteLen) <= 8) {
        if (((recLinMsg << (offsetBytePos*8)) >> ((8-chkByteLen)*8)) == chkRecMsgPart) {
          testStepPass("Diagnostic Response","Get positive response:0x%llX.",recLinMsg);
          errorCode = 0;
        }
        else {
          testStepFail("Diagnostic Response","Get negative response:0x%llX.",recLinMsg);
          errorCode = -10001;//negative response.
        }
      }
      else {
        testStepFail("Error","Fail to check the response, since the parameter input error:(offsetBytePos + chkByteLen) > 8.");
        errorCode = -1004;//fail to check,para input error.
      }
    }
    else {
      testStepFail("Diagnostic Response","No corresponding response.");
      errorCode = -1003;//No corresponding response.
    } 
    if (errorCode == 0)
      return 7;//kostial meaningful databyte length = 7
    else
      return errorCode;
  }
  else 
    return errorCode;
}

export int wait (dword waitMs) {
  int res;
  if (waitMs > 0) {
    res = testWaitForTimeout(waitMs);//testWaitForTimeout original error code: -2,-1
    testStep("Wait","Wait for %dms.",waitMs);
  }
  else if (waitMs == 0) {
    res = 0;
    testStep("Wait","Wait for %ldms.NOP.",waitMs);
  }
  else {
    testStepFail("Error","Input value of wait time < 0.");
    res = -3;
  }
  if (res == 0)
    return res;
  else
    return res - 1000;
}
/************************* communication data analyze *********************************/
export int decodeAsciiFromRecDiag (byte recMsg[],int arrayLen,int offsetBytePos,int chkByteLen,char decodeItem[]) {
  char decodedAsciiString[100];
  int i;
  if (arrayLen > 0) {
    if (arrayLen >= offsetBytePos+chkByteLen) {
      for (i=0;i<chkByteLen;i++)
        decodedAsciiString[i] = recMsg[offsetBytePos+i];
      decodedAsciiString[i] = '\0';
      testStep("Decode Response as ASCII","%s: %s.",decodeItem,decodedAsciiString);
      return 0;//success
    }
    else {
      testStepFail("Error","Response byte number < offsetBytePos + chkByteLen. ByteNum = %d,offsetBytePos + chkByteLen = %d.",arrayLen,offsetBytePos + chkByteLen);
      return -1005;
    }
  }
  else {
    testStepFail("Error","Error code = %d, Something wrong at communication.",arrayLen);
    return arrayLen;
  }
}

/****************************vtSystem related*************************************/
export int vtSysPwrSupInit (char pwrConnectWay[]) {//pwrConnectWay[] gets from key name in section vt7001Cfg 
  char namespace[100],vt7001CfgInfo[3];
  int numOfValsReadIn,res;
  numOfValsReadIn = getCfgDataArray("vt7001Cfg",pwrConnectWay,vt7001CfgInfo);
  if (numOfValsReadIn == 3) {
    if ((vt7001CfgInfo[1] != 0) || (vt7001CfgInfo[2] < 1) || (vt7001CfgInfo[2] > 2)) {
      testStepFail("Error","There is something wrong with your interConnectionMode and pwrOutputChannel configuration.");
      return -1002;
    }
    else {
      snprintf(namespace,elcount(namespace),"VTS::M%d_VT7001",vt7001CfgInfo[0]);
      res = vtsSetInterconnectionMode(namespace,vt7001CfgInfo[1]);//sysvar::VTS::M12_VT7001.SetInterconnectionMode(0);//Interconnection settings mode:supint,internal power supply connects to both I1 & I2.
      if (res == 0) {
        snprintf(namespace,elcount(namespace),"VTS::M%d_SupInt",vt7001CfgInfo[0]);
        res = vtsSetRefVoltageMode(namespace,1);//sysvar::VTS::M12_SupInt.SetRefVoltageMode(1);//M12_SupInt:Output:Ref Voltage mode = constant
        if (res == 0) {
          snprintf(namespace,elcount(namespace),"VTS::M%d_Out%d",vt7001CfgInfo[0],vt7001CfgInfo[2]);
          res = sysSetVariableInt(namespace,"Active",1);//@sysvar::VTS::M12_Out2::Active = 1;//M12_Out2:OUT2 pin connects to I2;
          if (res == 0)
            return 0;
          else
            return res*(-1)-1006;//distinguish the error between vtsSet and sysSet;
        }
        else
          return res - 1002;//vtsSetRefVoltageMode's error code meaning is the same with vtsSetInterconnectionMode
      }
      else 
        return res - 1002;
    }
  }
  else {
    testStepFail("Error","The value number in section:vt7001Cfg,key name:%s is %d, not equal to 3. Please check the paraCfg.ini file.",pwrConnectWay,numOfValsReadIn);
    return -1001;
  }
}

export int vtSysWithExPwrSupInit (char pwrConnectWay[]) {//pwrConnectWay[] gets from key name in section vt7001Cfg
  char namespace[100],vt7001CfgInfo[3];
  int numOfValsReadIn,res;
  numOfValsReadIn = getCfgDataArray ("vt7001Cfg",pwrConnectWay,vt7001CfgInfo);
  if (numOfValsReadIn == 3) {
    if ((vt7001CfgInfo[1] < 1) || (vt7001CfgInfo[1] > 2) || (vt7001CfgInfo[2] < 1) || (vt7001CfgInfo[2] > 2)) {
      testStepFail("Error","There is something wrong with your interConnectionMode and pwrOutputChannel configuration.");
      return -1002;
    }
    else {
      snprintf(namespace,elcount(namespace),"VTS::M%d_VT7001",vt7001CfgInfo[0]);
      res = vtsSetInterconnectionMode(namespace,vt7001CfgInfo[1]);//sysvar::VTS::M12_VT7001.SetInterconnectionMode(1);
      if (res == 0) {
        snprintf(namespace,elcount(namespace),"VTS::M%d_Sup%d",vt7001CfgInfo[0],vt7001CfgInfo[1]);
        res = vtsSetRefVoltageMode(namespace,1);//sysvar::VTS::M12_Sup1.SetRefVoltageMode(1);//M12_Sup1 output: Ref Voltage Mode = constant
        if (res == 0) {
          res = vtsSetMaxCurrentMode(namespace,1);//sysvar::VTS::M12_Sup1.SetMaxCurrentMode(1); //max current mode = constant
          if (res == 0) {
            snprintf(namespace,elcount(namespace),"VTS::M%d_Out%d",vt7001CfgInfo[0],vt7001CfgInfo[2]);
            res = sysSetVariableInt(namespace,"Active",1);//@sysvar::VTS::M12_Out1::Active = 1;//M12_Out1:OUT1 pin connects to I1;
            if (res == 0)
              return 0;
            else
              return res*(-1)-1006;//distinguish the error between vtsSet and sysSet;
          }
          else
            return res - 1002;//vtsSetMaxCurrentMode,vtsSetRefVoltageMode,vtsSetInterconnectionMode shares the same error code meaning.
        }
        else
          return res - 1002;
      }
      else
        return res - 1002;
    }
  }
  else {
    testStepFail("Error","The value number in section:vt7001Cfg,key name:%s is %d, not equal to 3. Please check the paraCfg.ini file.",pwrConnectWay,numOfValsReadIn);
    return -1001;
  }
}

export int vtSysPwrSupVoltSet (char pwrConnectWay[], float volt) {//pwrConnectWay[] gets from key name in section vt7001Cfg
  char namespace[100],vt7001CfgInfo[3];
  int numOfValsReadIn,res;
  numOfValsReadIn = getCfgDataArray ("vt7001Cfg",pwrConnectWay,vt7001CfgInfo);
  if (numOfValsReadIn == 3) {
    snprintf(namespace,elcount(namespace),"VTS::M%d_SupInt",vt7001CfgInfo[0]);//***need to be updated
    res = sysSetVariableFloat(namespace,"RefVoltage",volt);
    if (res == 0) {
      testStep("set VBAT voltage status","set VBAT voltage = %4.2fV.",volt);
      res = wait(1000);
      if (res == 0)
        return 0;
      else
        return res -5;
    }
    else
      return res*(-1)-1001;
  }
  else {
    testStepFail("Error","The value number in section:vt7001Cfg,key name:%s is %d, not equal to 3. Please check the paraCfg.ini file.",pwrConnectWay,numOfValsReadIn);
    return -1001;
  }
}

export int vtSysExPwrSupSet (char pwrConnectWay[], float volt, float maxI, int k) {//pwrConnectWay[] gets from key name in section vt7001Cfg
  char namespace[100],vt7001CfgInfo[3];
  int numOfValsReadIn,res;
  numOfValsReadIn = getCfgDataArray ("vt7001Cfg",pwrConnectWay,vt7001CfgInfo);
  if (numOfValsReadIn == 3) {
    if ((vt7001CfgInfo[1] < 1) || (vt7001CfgInfo[1] > 2) || (vt7001CfgInfo[2] < 1) || (vt7001CfgInfo[2] > 2)) {
      testStepFail("Error","There is something wrong with your interConnectionMode or pwrOutputChannel configuration.");
      return -1002; 
    }
    else {
      snprintf(namespace,elcount(namespace),"VTS::M%d_Sup%d",vt7001CfgInfo[0],vt7001CfgInfo[1]);
      res = sysSetVariableFloat(namespace,"RefVoltage",volt/k);//@sysvar::VTS::M12_Sup1::RefVoltage = 1.0v;
      if (res == 0) {
        testStep("set external power supply control voltage","set @sysvar::VTS::M%d_Sup%d::RefVoltage = %2.1fv;.",vt7001CfgInfo[0],vt7001CfgInfo[1],volt/k);
        res = sysSetVariableFloat(namespace,"MaxCurrent",maxI/k);//@sysvar::VTS::M12_Sup1::MaxCurrent = 2.5;
        if (res == 0) {
          testStep("set external power supply control voltage","set @sysvar::VTS::M%d_Sup%d::MaxCurrent = %2.1fv;.",vt7001CfgInfo[0],vt7001CfgInfo[1],maxI/k);
          res = wait(1000);
          if (res == 0)
            return 0;
          else
            return res - 6;
        }
        else
          return res*(-1)-1002;
      }
      else
        return res*(-1)-1002;
    }
  }
  else {
    testStepFail("Error","The value number in section:vt7001Cfg,key name:%s is %d, not equal to 3. Please check the paraCfg.ini file.",pwrConnectWay,numOfValsReadIn);
    return -1001;
  }
}
  
export int vtSysPwrSupVoltGet (char pwrConnectWay[], float highLimitV, float lowLimitV) {//pwrConnectWay[] gets from key name in section vt7001Cfg
  float readValue;
  char namespace[100],vt7001CfgInfo[3];
  int numOfValsReadIn;
  numOfValsReadIn = getCfgDataArray ("vt7001Cfg",pwrConnectWay,vt7001CfgInfo);
  if (numOfValsReadIn == 3) {
    snprintf(namespace,elcount(namespace),"VTS::M%d_Out%d",vt7001CfgInfo[0],vt7001CfgInfo[2]);
    readValue = sysGetVariableFloat(namespace,"AvgVoltage");
    if ((readValue < lowLimitV) || (readValue > highLimitV)) {
      testStepFail("get VBAT voltage status","VBAT = %4.2fV,out of range [%4.2fV~%4.2fV],",readValue,lowLimitV,highLimitV);
	    return -10001;
	  }
    else {
      testStepPass("get VBAT voltage status","VBAT = %4.2fV,in the range [%4.2fV~%4.2fV],",readValue,lowLimitV,highLimitV);
	    return 0;
	  }
  }
  else {
    testStepFail("Error","The value number in section:vt7001Cfg,key name:%s is %d, not equal to 3. Please check the paraCfg.ini file.",pwrConnectWay,numOfValsReadIn);
    return -1001;
  }
}

export int vtSysPwrSupCurrGet (char pwrConnectWay[],float highLimitA,float lowLimitA,enum vt7001MeasureRange vt7001MeasureRange,enum currentUnit currentUnit) {//pwrConnectWay[] gets from key name in section vt7001Cfg
  float readValue;
  int numOfValsReadIn,res;
  char namespace[100],vt7001CfgInfo[3],iUnit[3][3] = {"uA","mA","A"};
  numOfValsReadIn = getCfgDataArray ("vt7001Cfg",pwrConnectWay,vt7001CfgInfo);
  if (numOfValsReadIn == 3) {
    snprintf(namespace,elcount(namespace),"VTS::M%d_Out%d",vt7001CfgInfo[0],vt7001CfgInfo[2]);
    res = vtsSetMinCurrentMeasurementRange(namespace,vt7001MeasureRange);//sysvar::VTS::M12_Out1.SetMinCurrentMeasurementRange(0);
    if (res == 0) {
      readValue = sysGetVariableFloat(namespace,"AvgCurrent");
      if ((readValue < lowLimitA) || (readValue > highLimitA)) {
        testStepFail("get VBAT current status","VBAT current = %6.3f%s,out of range [%6.3f%s~%6.3f%s],",readValue*(_pow(10,6-currentUnit*3)),iUnit[currentUnit],lowLimitA*(_pow(10,6-currentUnit*3)),iUnit[currentUnit],highLimitA*(_pow(10,6-currentUnit*3)),iUnit[currentUnit]);
		    return -10001;
      }
      else {
        testStepPass("get VBAT current status","VBAT current = %6.3f%s,in the range [%6.3f%s~%6.3f%s],",readValue*(_pow(10,6-currentUnit*3)),iUnit[currentUnit],lowLimitA*(_pow(10.0,6-currentUnit*3)),iUnit[currentUnit],highLimitA*(_pow(10,6-currentUnit*3)),iUnit[currentUnit]); 
        return 0;
	    }
    }
    else
      return res-1001;
  }
  else {
    testStepFail("Error","The value number in section:vt7001Cfg,key name:%s is %d, not equal to 3. Please check the paraCfg.ini file.",pwrConnectWay,numOfValsReadIn);
    return -1001;
  } 
}

export int prodPwmOutChk (char pinName[],float expectedFreq,float expectedDuty,int deviationRange) {//pinName[] gets from key name in section vt2516Cfg
  char namespace[100],vt2516CfgInfo[2];
  float pwmFreq,pwmDc,avgVolt;
  int numOfValsReadIn,res;
  numOfValsReadIn = getCfgDataArray ("vt2516Cfg",pinName,vt2516CfgInfo);
  if (numOfValsReadIn == 2) {
    snprintf(namespace,elcount(namespace),"VTS::M%d_Ch%d",vt2516CfgInfo[0],vt2516CfgInfo[1]);
    pwmFreq = sysGetVariableFloat(namespace,"PWMFreq");
    pwmDc = sysGetVariableFloat(namespace,"PWMDC");
    avgVolt = sysGetVariableFloat(namespace,"Avg");
    if ((expectedFreq == 0) && (expectedDuty == 0)) {
      if ((avgVolt < 0.5) && (pwmFreq == 0) && (pwmDc == 0)) {
        testStepPass("check PWM","pin %s :output frequency = %4.1fHz, duty = %3.1f%%, average voltage = %4.2fV",pinName,pwmFreq,pwmDc,avgVolt);
        return 0;
      }
      else {
        testStepFail("check PWM","check PWM fail -> pin %s :output frequency = %4.1fHz vs expectedFreq = %4.1fHz, duty = %3.1f%% vs expectedDuty = %3.1f%%, average voltage = %4.2fV",pinName,pwmFreq,expectedFreq,pwmDc,expectedDuty,avgVolt);
        return -10001;
      }
    }
    else if ((expectedFreq == 0) && (expectedDuty == 100)) {
      if ((avgVolt > 10) && (pwmFreq == 0) && (pwmDc == 100)) {
        testStepPass("check PWM","pin %s :output frequency = %4.1fHz, duty = %3.1f%%, average voltage = %4.2fV",pinName,pwmFreq,pwmDc,avgVolt);
        return 0;
      }
      else {
        testStepFail("check PWM","check PWM fail -> pin %s :output frequency = %4.1fHz  vs expectedFreq = %4.1fHz, duty = %3.1f%% vs expectedDuty = %3.1f%%, average voltage = %4.2fV",pinName,pwmFreq,expectedFreq,pwmDc,expectedDuty,avgVolt);
        return -10002;
      }
    }
    else {
      if ((pwmFreq >= expectedFreq*0.995) && (pwmFreq <= expectedFreq*1.005)) {
        testStepPass("check PWM Frequency","pin %s :output frequency = %4.1fHz",pinName,pwmFreq);
        res = 0;
      }
      else {
        testStepFail("check PWM Frequency","pin %s :output frequency = %4.1fHz,out of range [%4.1f-%4.1f]Hz.",pinName,pwmFreq,expectedFreq*0.995,expectedFreq*1.005);
        res = -10003;
      }
      if ((pwmDc >= expectedDuty-deviationRange) && (pwmDc <= expectedDuty+deviationRange))
        testStepPass("check PWM Duty","pin %s :output duty = %3.1f%%",pinName,pwmDc);
      else {
        testStepFail("check PWM Duty","pin %s :output duty = %3.1f%%,out of range [%3.1f%%-%3.1f%%].",pinName,pwmDc,expectedDuty-deviationRange,expectedDuty+deviationRange);
        if (res == 0)
          res = -10004;
        else
          res = -10005;
      }
      return res;
    }
  }
  else {
    testStepFail("Error","The value number in section:vt2516Cfg,key name:%s is %d, not equal to 2. Please check the paraCfg.ini file.",pinName,numOfValsReadIn);
    return -1001;
  }
}

export int64 pwmRiseStartTimingMeas (char pinName[]) {//pinName[] gets from key name in section vt2516Cfg
  char namespace[100],vt2516CfgInfo[2];
  float pwmFreq,pwmDc_o,pwmDc_u;
  int64 tRiseStart,tMeaStart;
  int numOfValsReadIn;
  numOfValsReadIn = getCfgDataArray ("vt2516Cfg",pinName,vt2516CfgInfo);
  if (numOfValsReadIn == 2) {
    snprintf(namespace,elcount(namespace),"VTS::M%d_Ch%d",vt2516CfgInfo[0],vt2516CfgInfo[1]);
    tMeaStart = timeNowInt64();
    pwmDc_o = sysGetVariableFloat(namespace,"PWMDC");
    do {
      pwmFreq = sysGetVariableFloat(namespace,"PWMFreq");
      pwmDc_u = sysGetVariableFloat(namespace,"PWMDC");
      //testStep("","freq=%f,t=%f",pwmFreq,_pow(10,-9)*(t1-t));
      testWaitForTimeout(1);
      tRiseStart = timeNowInt64();
      //testValidateTesterConfirmation("step1","",1);
    } while ((pwmDc_u - pwmDc_o < 0.1)&&(_pow(10,-9)*(tRiseStart-tMeaStart)<3));
    if (_pow(10,-9)*(tRiseStart-tMeaStart)>=3) {
      testStepFail("measure PWM rising edge","pin %s :PWM output didn't rise within 3s after rising start timing measurement. Output frequency = %5.2fHz, duty = %3.1f%% at this moment.",pinName,pwmFreq,pwmDc_u);
      return -10001; 
    }
    else {
      testStepPass("measure PWM rising edge","pin %s :PWM rising edge started at %5.2fms after rising start timing measurement. Output frequency = %5.2fHz, duty = %3.1f%% at this moment.",pinName,_pow(10,-6)*(tRiseStart-tMeaStart),pwmFreq,pwmDc_u);
      return tRiseStart;
    }
  }
  else {
    testStepFail("Error","The value number in section:vt2516Cfg,key name:%s is %d, not equal to 2. Please check the paraCfg.ini file.",pinName,numOfValsReadIn);
    return -1001;
  }
}

export int64 pwmRiseEndTimingMeas (char pinName[],float expectedFreq,float expectedDuty,int deviationRange) {//pinName[] gets from key name in section vt2516Cfg
  char namespace[100],vt2516CfgInfo[2];
  float pwmFreq,pwmDc_o,pwmDc_u,avgVolt;
  int64 tRiseEnd,tMeaStart;
  int flag,direction,numOfValsReadIn;
  numOfValsReadIn = getCfgDataArray ("vt2516Cfg",pinName,vt2516CfgInfo);
  if (numOfValsReadIn == 2) {
    snprintf(namespace,elcount(namespace),"VTS::M%d_Ch%d",vt2516CfgInfo[0],vt2516CfgInfo[1]);
    pwmDc_o = sysGetVariableFloat(namespace,"PWMDC");
    tMeaStart = timeNowInt64();
    tRiseEnd = tMeaStart;
    flag = 0;
    direction = 1;
    do {
      pwmFreq = sysGetVariableFloat(namespace,"PWMFreq");
      pwmDc_u = sysGetVariableFloat(namespace,"PWMDC");
      avgVolt = sysGetVariableFloat(namespace,"Avg");
      //testStep("","freq=%f,duty_o=%f,duty_u=%f,t=%fms",pwmFreq,pwmDc_o,pwmDc_u,_pow(10,-6)*(timeNowInt64()-tRiseStart));
      if (pwmDc_u - pwmDc_o >= 0.1) {//still rising
        //testStep("","pwmDc_o = %f%%,pwmDc_u=%f%%",pwmDc_o,pwmDc_u);
        pwmDc_o = pwmDc_u;
        tRiseEnd = timeNowInt64();
      }
      else {
        if (pwmDc_o - pwmDc_u >= 0.1) {
          flag = 1; //start falling, so quit while loop
          direction = -1;
        }
        else {//abs(pwmDc_u-pwmDc_o) < 0.1, treat it as normal vibration
          if (_pow(10,-6)*(timeNowInt64()-tRiseEnd)>1500) //sometimes duty from 98% to 100% can be very long 
            flag = 1;//if pwmDc didn't change within 1500ms, so it will be determined as stable.pwmdc may last for about 200ms then rise again.
        }
      }
      testWaitForTimeout(1);
    } while ((!flag) && (_pow(10,-9)*(tRiseEnd-tMeaStart)<5));
    if (_pow(10,-9)*(tRiseEnd-tMeaStart)>=5) {
      testStepFail("measure PWM rising edge","pin %s :PWM was still not stable within 5s after rising end timing measurment.",pinName);
      return -10002;
    }
    else {
      testStepPass("measure PWM rising edge","pin %s :PWM rising edge ended at %6.2fms after rising end timing measurment.",pinName,_pow(10,-6)*(tRiseEnd-tMeaStart));
      if (expectedDuty == 100) {//when duty=100%
        if ((avgVolt > 10) && (pwmFreq == 0) && (pwmDc_u == 100))
          testStepPass("check PWM","pin %s :output frequency = %4.1fHz, duty = %3.1f%%, average voltage = %4.2fV",pinName,pwmFreq,pwmDc_u,avgVolt);
        else
          testStepFail("check PWM","check PWM fail -> pin %s :output frequency = %4.1fHz vs expectedFreq = 0Hz, duty = %3.1f%% vs expectedDuty = 100%%, average voltage = %4.2fV",pinName,pwmFreq,pwmDc_u,avgVolt);
      }
      else {//when duty != 100%
        if ((pwmFreq > expectedFreq*0.995) && (pwmFreq < expectedFreq*1.005) && (pwmDc_u > expectedDuty-deviationRange) && (pwmDc_u < expectedDuty+deviationRange))
          testStepPass("check PWM","pin %s :output frequency = %4.1fHz,output duty = %3.1f%%.",pinName,pwmFreq,pwmDc_u);
        else
          testStepFail("check PWM","check PWM fail -> pin %s :output frequency = %4.1fHz vs expectedFreq = %4.1fHz, duty = %3.1f%% vs expectedDuty = %3.1f%%.",pinName,pwmFreq,expectedFreq,pwmDc_u,expectedDuty);
      }
      return tRiseEnd * direction;
    }
  }
  else {
    testStepFail("Error","The value number in section:vt2516Cfg,key name:%s is %d, not equal to 2. Please check the paraCfg.ini file.",pinName,numOfValsReadIn);
    return -1001;
  }
}

export int64 pwmFallStartTimingMeas (char pinName[]) {//pinName[] gets from key name in section vt2516Cfg
  char namespace[100],vt2516CfgInfo[2];
  float pwmFreq,pwmDc_o,pwmDc_u;
  int64 tFallStart,tMeaStart;
  int numOfValsReadIn;
  numOfValsReadIn = getCfgDataArray ("vt2516Cfg",pinName,vt2516CfgInfo);
  if (numOfValsReadIn == 2) {
    snprintf(namespace,elcount(namespace),"VTS::M%d_Ch%d",vt2516CfgInfo[0],vt2516CfgInfo[1]);
    tMeaStart = timeNowInt64();
    pwmDc_o = sysGetVariableFloat(namespace,"PWMDC");
    testStep("measure PWM falling edge","Initial PWM duty = %4.2f%% when PWM falling edge measurement began.",pwmDc_o);
    do {
      pwmFreq = sysGetVariableFloat(namespace,"PWMFreq");
      pwmDc_u = sysGetVariableFloat(namespace,"PWMDC");
      //testStep("","freq=%f,duty_o=%f,duty_u=%f,t=%fms",pwmFreq,pwmDc_o,pwmDc_u,_pow(10,-6)*(timeNowInt64()-tRiseStart));
      if (pwmDc_o - pwmDc_u >= 0.1)//avoid little vibration like from 20.68 to 20.69
        tFallStart = timeNowInt64();
      testWaitForTimeout(1);
    } while ((pwmDc_o - pwmDc_u < 0.1) && (_pow(10,-9)*(timeNowInt64() - tMeaStart)<60));
    if (_pow(10,-9)*(timeNowInt64() - tMeaStart)>= 60) {
      testStepFail("measure PWM falling edge","pin %s :PWM falling edge didn't start within 60s after falling start timing measurement.",pinName);
      return -10003;
    }
    else {
      testStepPass("measure PWM falling edge","pin %s :PWM falling edge started at %6.2fms after falling start timing measurement.Output frequency = %5.2fHz, duty changed from %3.1f%% to %3.1f%% at this moment.",pinName,_pow(10,-6)*(tFallStart - tMeaStart),pwmFreq,pwmDc_o,pwmDc_u);
      return tFallStart;
    }
  }
  else {
    testStepFail("Error","The value number in section:vt2516Cfg,key name:%s is %d, not equal to 2. Please check the paraCfg.ini file.",pinName,numOfValsReadIn);
    return -1001;
  }
}

export int64 pwmFallEndTimingMeas (char pinName[],float expectedFreq,float expectedDuty,int deviationRange) {//pinName[] gets from key name in section vt2516Cfg
  char namespace[100],vt2516CfgInfo[2];
  float pwmFreq,pwmDc_u,pwmDc_o,avgVolt;
  int64 tFallEnd,tMeaStart;
  int flag,direction,numOfValsReadIn;
  numOfValsReadIn = getCfgDataArray ("vt2516Cfg",pinName,vt2516CfgInfo);
  if (numOfValsReadIn == 2) {
    snprintf(namespace,elcount(namespace),"VTS::M%d_Ch%d",vt2516CfgInfo[0],vt2516CfgInfo[1]);
    pwmDc_o = sysGetVariableFloat(namespace,"PWMDC");
    tMeaStart = timeNowInt64();
    tFallEnd = tMeaStart;
    flag = 0;
    direction = 1;
    do {
      pwmFreq = sysGetVariableFloat(namespace,"PWMFreq");
      pwmDc_u = sysGetVariableFloat(namespace,"PWMDC");
      avgVolt = sysGetVariableFloat(namespace,"Avg");
      //testStep("","freq=%f,duty_o=%f,duty_u=%f,t=%fms",pwmFreq,pwmDc_o,pwmDc_u,_pow(10,-6)*(timeNowInt64()-tRiseStart));
      if (pwmDc_o - pwmDc_u >= 0.1) {//still falling
        //testStep("","pwmDc_o = %f%%,pwmDc_u=%f%%",pwmDc_o,pwmDc_u);
        pwmDc_o = pwmDc_u;
        tFallEnd = timeNowInt64();
      }
      else {
        if (pwmDc_u - pwmDc_o >= 0.1) {
          flag = 1; //start rising, so quit while loop
          direction = -1;
        }
        else {//abs(pwmDc_u-pwmDc_o) < 0.1, treat it as normal vibration
          if (_pow(10,-6)*(timeNowInt64()-tFallEnd)>1500)
            flag = 1;//if pwmDc didn't change within 1500ms, so it will be determined as stable.a specific pwmdc may last for about 200ms then fall again.
        }
      }
      testWaitForTimeout(1);
    } while ((!flag) && (_pow(10,-9)*(tFallEnd - tMeaStart)<5));
    if (_pow(10,-9)*(tFallEnd - tMeaStart)>=5) {
      testStepFail("measure PWM falling edge","pin %s :output frequency = %4.1fHz,output duty = %4.2f%%.PWM falling edge didn't complete within 5s after falling end timing measurment.",pinName,pwmFreq,pwmDc_u);
      return -10004;
    }
    else { 
      testStepPass("measure PWM falling edge","pin %s :output frequency = %4.1fHz,output duty = %4.2f%%.PWM falling edge stopped at %6.2fms after falling end timing measurment.",pinName,pwmFreq,pwmDc_u,_pow(10,-6)*(tFallEnd-tMeaStart));
      if (expectedDuty == 0) {//when duty=0%
        if ((avgVolt < 0.5) && (pwmFreq == 0) && (pwmDc_u == 0))
          testStepPass("check PWM","pin %s :output frequency = %4.1fHz, duty = %3.1f%%, average voltage = %4.2fV",pinName,pwmFreq,pwmDc_u,avgVolt);
        else
          testStepFail("check PWM","check PWM fail -> pin %s :output frequency = %4.1fHz vs expectedFreq = 0Hz, duty = %3.1f%% vs expectedDuty = 0%%, average voltage = %4.2fV",pinName,pwmFreq,pwmDc_u,avgVolt);
      }
      else {//when duty != 0%
        if ((pwmFreq > expectedFreq*0.995) && (pwmFreq < expectedFreq*1.005) && (pwmDc_u > expectedDuty-deviationRange) && (pwmDc_u < expectedDuty+deviationRange))
          testStepPass("check PWM","pin %s :output frequency = %4.1fHz,output duty = %3.1f%%.",pinName,pwmFreq,pwmDc_u);
        else
          testStepFail("check PWM","check PWM fail -> pin %s :output frequency = %4.1fHz vs expectedFreq = %4.1fHz, duty = %3.1f%% vs expectedDuty = %3.1f%%.",pinName,pwmFreq,expectedFreq,pwmDc_u,expectedDuty);
      }
      return tFallEnd * direction;
    }
  }
  else {
    testStepFail("Error","The value number in section:vt2516Cfg,key name:%s is %d, not equal to 2. Please check the paraCfg.ini file.",pinName,numOfValsReadIn);
    return -1001;
  }
}

export int prodPwmOutRisingEdgeMeas (char productPwmOutMode[]) {//productPwmOutMode[] gets from key name in section: pwmTimeCfg
  char cfgStrArray[10][30];
  double tRiseStart,tRiseEnd;
  int paraNum;
  paraNum = getCfgStrArray("pwmTimeCfg",productPwmOutMode,cfgStrArray);
  if (paraNum != -1001) {
    tRiseStart = pwmRiseStartTimingMeas(cfgStrArray[0]);
    if ((tRiseStart != -1001) && (tRiseStart != -10001)) {
      tRiseEnd = pwmRiseEndTimingMeas(cfgStrArray[0],atodbl(cfgStrArray[1]),atodbl(cfgStrArray[2]),atol(cfgStrArray[5]));
      if ((tRiseEnd != -1001) && (tRiseEnd != -10002)) {
        if (_pow(10,-6)*(abs(tRiseEnd) - tRiseStart) <= atol(cfgStrArray[6])) {
          testStepPass("measure PWM rising edge","PIN %s outputs PWM, rise to frequency %sHz,duty %s%% costs %6.2fms,within %sms.",cfgStrArray[0],cfgStrArray[1],cfgStrArray[2],_pow(10,-6)*(abs(tRiseEnd) - tRiseStart),cfgStrArray[6]);
          return 0;
        }
        else {
          testStepFail("measure PWM rising edge","PIN %s outputs PWM, rise to frequency %sHz,duty %s%% costs %6.2fms,longer than %sms.",cfgStrArray[0],cfgStrArray[1],cfgStrArray[2],_pow(10,-6)*(abs(tRiseEnd) - tRiseStart),cfgStrArray[6]);
          return -10005;
        }
      }
      else
        return tRiseEnd;
    }
    else
      return tRiseStart;
  }
  else
    return -1001;
}

export int prodPwmOutKeepTimeMeas (char productPwmOutMode[]) {//productPwmOutMode[] gets from key name in section: pwmTimeCfg
  char cfgStrArray[10][30];
  double tFallStart,tRiseEnd;
  int paraNum;
  paraNum = getCfgStrArray("pwmTimeCfg",productPwmOutMode,cfgStrArray);
  if (paraNum != -1001) {
    tRiseEnd = pwmRiseEndTimingMeas(cfgStrArray[0],atodbl(cfgStrArray[1]),atodbl(cfgStrArray[2]),atol(cfgStrArray[5]));
    if ((tRiseEnd != -1001) && (tRiseEnd != -10002)) {
      tFallStart = pwmFallStartTimingMeas (cfgStrArray[0]);
      if ((tFallStart != -1001) && (tFallStart != -10003)) {
        if ((_pow(10,-6)*(tFallStart - abs(tRiseEnd)) <= atol(cfgStrArray[7]) + atol(cfgStrArray[8])) && (_pow(10,-6)*(tFallStart - abs(tRiseEnd)) >= atol(cfgStrArray[7]) - atol(cfgStrArray[8]))) {
          testStepPass("measure PWM keep time","PIN %s outputs PWM, keeps at frequency %sHz,duty %s%% for %6.2fms,within range [%s ¡À %sms].",cfgStrArray[0],cfgStrArray[1],cfgStrArray[2],_pow(10,-6)*(tFallStart - abs(tRiseEnd)),cfgStrArray[7],cfgStrArray[8]);
          return 0;
        }
        else {
          testStepFail("measure PWM keep time","PIN %s outputs PWM, keeps at frequency %sHz,duty %s%% for %6.2fms,out of range [%s ¡À %sms].",cfgStrArray[0],cfgStrArray[1],cfgStrArray[2],_pow(10,-6)*(tFallStart - abs(tRiseEnd)),cfgStrArray[7],cfgStrArray[8]);
          return -10006;
        }
      }
      else
        return tFallStart;
    }
    else
      return tRiseEnd;
  }
  else
    return -1001;
}

export int prodPwmOutFallingEdgeMeas (char productPwmOutMode[]) {//productPwmOutMode[] gets from key name in section: pwmTimeCfg
  char cfgStrArray[10][30];
  double tFallStart,tFallEnd;
  int paraNum;
  paraNum = getCfgStrArray("pwmTimeCfg",productPwmOutMode,cfgStrArray);
  if (paraNum != -1001) {
    tFallStart = pwmFallStartTimingMeas(cfgStrArray[0]);
    if ((tFallStart != -1001) && (tFallStart != -10003)) {
      tFallEnd = pwmFallEndTimingMeas(cfgStrArray[0],atodbl(cfgStrArray[3]),atodbl(cfgStrArray[4]),atol(cfgStrArray[5]));
      if ((tFallEnd != -1001) && (tFallEnd != -10004)) {
        if (_pow(10,-6)*(abs(tFallEnd) - tFallStart) <= atol(cfgStrArray[9])) {
          testStepPass("measure PWM falling edge","PIN %s outputs PWM,PWM falling from frequency %sHz,duty %s%% to frequency %sHz,duty %s%% costs %6.2fms,within %sms.",cfgStrArray[0],cfgStrArray[1],cfgStrArray[2],cfgStrArray[3],cfgStrArray[4],_pow(10,-6)*(abs(tFallEnd) - tFallStart),cfgStrArray[9]);
          return 0;
        }
        else {
          testStepFail("measure PWM falling edge","PIN %s outputs PWM,PWM falling from frequency %sHz,duty %s%% to frequency %sHz,duty %s%% costs %6.2fms,longer than %sms.",cfgStrArray[0],cfgStrArray[1],cfgStrArray[2],cfgStrArray[3],cfgStrArray[4],_pow(10,-6)*(abs(tFallEnd) - tFallStart),cfgStrArray[9]);
          return -10007;
        }
      }
      else
        return tFallEnd;
    }
    else
      return tFallStart;
  }
  else
    return -1001;
}

export int prodPwmOutRiseFallCurveMeas (char productPwmOutMode[]) {
  char cfgStrArray[10][30];
  double tRiseStart,tRiseEnd,tFallStart,tFallEnd;
  double tRise, tFall;
  int paraNum,res;
  paraNum = getCfgStrArray("pwmTimeCfg",productPwmOutMode,cfgStrArray);
  if (paraNum != -1001) {
    tRiseStart = pwmRiseStartTimingMeas(cfgStrArray[0]);
    if ((tRiseStart != -1001) && (tRiseStart != -10001)) {
      tRiseEnd = pwmRiseEndTimingMeas(cfgStrArray[0],atodbl(cfgStrArray[1]),atodbl(cfgStrArray[2]),atol(cfgStrArray[5]));
      if ((tRiseEnd != -1001) && (tRiseEnd != -10002)) {
        tRise = _pow(10,-6)*(abs(tRiseEnd) - tRiseStart);
        //testStep("","tRiseEnd=%lld,abs(tRiseEnd)=%lld,abs(tRiseEnd) - tRiseStart=%lld,tRiseStart=%lld,tRise=%f",tRiseEnd,abs(tRiseEnd),abs(tRiseEnd) - tRiseStart,tRiseStart,tRise);
        if (tRise <= atol(cfgStrArray[6])) {
          testStepPass("measure PWM rising edge","pin %s :PWM rising time is %6.2fms,within %sms.",cfgStrArray[0],tRise,cfgStrArray[6]);
          res = 0;
        }
        else {
          testStepFail("measure PWM rising edge","pin %s :PWM rising time is %6.2fms,longer than %sms.",cfgStrArray[0],tRise,cfgStrArray[6]);
          res = -10005;
        }
        if (tRiseEnd < 0)
          tFallStart = abs(tRiseEnd);
        else
          tFallStart = pwmFallStartTimingMeas(cfgStrArray[0]);
        if ((tFallStart != -1001) && (tFallStart != -10003)){
          tFallEnd = pwmFallEndTimingMeas (cfgStrArray[0],atodbl(cfgStrArray[3]),atodbl(cfgStrArray[4]),atol(cfgStrArray[5]));
          if ((tFallEnd != -1001) && (tFallEnd != -10004)) {
            tFall = _pow(10,-6)*(abs(tFallEnd) - tFallStart);
            if (tFall <= atol(cfgStrArray[9]))
              testStepPass("measure PWM falling edge","pin %s :PWM falling time is %6.2fms,within %sms.",cfgStrArray[0],tFall,cfgStrArray[9]);
            else {
              testStepFail("measure PWM falling edge","pin %s :PWM falling time is %6.2fms,longer than %sms.",cfgStrArray[0],tFall,cfgStrArray[9]);
              if (res == 0)
                res = -10007;
              else
                res = -10008;
            }
          }
          else
            res = tFallEnd;
        }
        else {
          testStepFail("measure PWM falling edge","pin %s :No falling edge occured.",cfgStrArray[0]);
          res = tFallStart;
        }
        return res;
      }
      else
        return tRiseEnd;
    }
    else {
      testStepFail("measure PWM rising edge","pin %s :No wave change occured.",cfgStrArray[0]);
      return tRiseStart;
    }
  }
  else
    return -1001;
}

/*export void prodPwmOutRiseRiseCurveMeas (char pwmMode[]) {
  char namespace[100],vt2516CfgInfo[2],cfgStrArray[5][30];
  float pwmFreq,pwmDc_o,pwmDc_u,avgVolt;
  int64 tRiseStart,tRiseEnd,tMeaStart;
  int flag,paraNum;
  paraNum = getCfgStrArray("pwmRiseEdgeCfg",pwmMode,cfgStrArray);
  if (paraNum != -1001) {
    getCfgDataArray ("vt2516Cfg",cfgStrArray[0],vt2516CfgInfo);
    snprintf(namespace,elcount(namespace),"VTS::M%d_Ch%d",vt2516CfgInfo[0],vt2516CfgInfo[1]);
    tMeaStart = timeNowInt64();
    do {
      pwmFreq = sysGetVariableFloat(namespace,"PWMFreq");
      pwmDc_o = sysGetVariableFloat(namespace,"PWMDC");
      //testStep("","freq=%f,t=%f",pwmFreq,_pow(10,-9)*(t1-t));
      testWaitForTimeout(1);
      tRiseStart = timeNowInt64();
      //testValidateTesterConfirmation("step1","",1);
    } while ((pwmFreq == 0) && (_pow(10,-9)*(tRiseStart-tMeaStart)<3));
    if (_pow(10,-9)*(tRiseStart-tMeaStart)>3)
      testStepFail("measure PWM rising edge","pin %s :PWM output didn't start within 3s.",cfgStrArray[0]);
    else {
      testStepPass("measure PWM rising edge","pin %s :PWM rising started at %5.2fms after trigger.",cfgStrArray[0],_pow(10,-6)*(tRiseStart-tMeaStart));
      flag = 0;
      tRiseEnd = tRiseStart;
      do {
        pwmFreq = sysGetVariableFloat(namespace,"PWMFreq");
        pwmDc_u = sysGetVariableFloat(namespace,"PWMDC");
        avgVolt = sysGetVariableFloat(namespace,"Avg");
        //testStep("","freq=%f,duty_o=%f,duty_u=%f,t=%fms",pwmFreq,pwmDc_o,pwmDc_u,_pow(10,-6)*(timeNowInt64()-tRiseStart));
        if (pwmDc_u - pwmDc_o > 0.1) {
          //testStep("","pwmDc_o = %f%%,pwmDc_u=%f%%",pwmDc_o,pwmDc_u);
          pwmDc_o = pwmDc_u;
          tRiseEnd = timeNowInt64();
        }
        else {
          if (_pow(10,-6)*(timeNowInt64()-tRiseEnd) >2000) 
            flag = 1;//if pwmDc didn't change within 2000ms, so it will be determined as stable
        }
        testWaitForTimeout(1);
      } while ( (!flag) && (_pow(10,-9)*(tRiseEnd - tRiseStart)<5));
      if (_pow(10,-9)*(tRiseEnd - tRiseStart)>=5)
        testStepFail("measure PWM rising edge","pin %s :PWM was still not stable within 5s after trigger.",cfgStrArray[0]);
      else {
        if ((_pow(10,-6)*(tRiseEnd - tRiseStart)<=atol(cfgStrArray[4])))
          testStepPass("measure PWM rising edge","pin %s :PWM rising stopped at %6.2fms after trigger.Rising time is %6.2fms,within %sms.",cfgStrArray[0],_pow(10,-6)*(tRiseEnd-tMeaStart),_pow(10,-6)*(tRiseEnd-tRiseStart),cfgStrArray[4]);
        else 
          testStepFail("measure PWM rising edge","pin %s :PWM rising stopped at %6.2fms after trigger.Rising time is %6.2fms,larger than %sms.",cfgStrArray[0],_pow(10,-6)*(tRiseEnd-tMeaStart),_pow(10,-6)*(tRiseEnd-tRiseStart),cfgStrArray[4]);
        if ((atol(cfgStrArray[1]) == 0) && (atol(cfgStrArray[2]) == 100)) {//when duty=100%
          if ((avgVolt > 10) && (pwmFreq == 0) && (pwmDc_u == 100))
            testStepPass("check PWM","pin %s :output frequency = %4.1fHz, duty = %3.1f%%, average voltage = %4.2fV",cfgStrArray[0],pwmFreq,pwmDc_u,avgVolt);
          else
            testStepFail("check PWM","check PWM fail -> pin %s :output frequency = %4.1fHz  vs expectedFreq = %sHz, duty = %3.1f%% vs expectedDuty = %s%%, average voltage = %4.2fV",cfgStrArray[0],pwmFreq,cfgStrArray[1],pwmDc_u,cfgStrArray[2],avgVolt);
        }
        else {//when duty != 100%
          if ((pwmFreq > atol(cfgStrArray[1])*0.995) && (pwmFreq < atol(cfgStrArray[1])*1.005))
            testStepPass("check PWM Frequency","pin %s :output frequency = %4.1fHz",cfgStrArray[0],pwmFreq);
          else
            testStepFail("check PWM Frequency","pin %s :output frequency = %4.1fHz,out of range [%4.1f-%4.1f]Hz.",cfgStrArray[0],pwmFreq,atol(cfgStrArray[1])*0.995,atol(cfgStrArray[1])*1.005);
          if ((pwmDc_u > atol(cfgStrArray[2])-atol(cfgStrArray[3])) && (pwmDc_u < atol(cfgStrArray[2])+atol(cfgStrArray[3])))
            testStepPass("check PWM Duty","pin %s :output duty = %3.1f%%",cfgStrArray[0],pwmDc_u);
          else
            testStepFail("check PWM Duty","pin %s :output duty = %3.1f%%,out of range [%d%%-%d%%].",cfgStrArray[0],pwmDc_u,atol(cfgStrArray[2])-atol(cfgStrArray[3]),atol(cfgStrArray[2])+atol(cfgStrArray[3]));
        }
      }
    }
  }
}*/

export int chFixVoltDOSet (char pinName[],enum digitalLevel level) {//pinName[] gets from key name in section vt2516Cfg
  char vt2516CfgInfo[2],namespace[100];
  int numOfValsReadIn,res;
  numOfValsReadIn = getCfgDataArray ("vt2516Cfg",pinName,vt2516CfgInfo);
  if (numOfValsReadIn == 2) {
    snprintf(namespace,elcount(namespace),"VTS::M%d_Ch%d",vt2516CfgInfo[0],vt2516CfgInfo[1]);
    switch (level) {
      case Low:
        res = sysSetVariableInt(namespace,"RelayVBatt",0);
        if (res == 0) {
          res = testWaitForTimeout(200);
          if (res == 0) {
            res = sysSetVariableInt(namespace,"RelayGnd",1);
            if (res == 0) {
              res = testWaitForTimeout(200);
              if (res == 0) {
                testStep("VT outputs digital level for product input pin","For pin %s:Module%d channel%d generates low digital level.",pinName,vt2516CfgInfo[0],vt2516CfgInfo[1]);
                return 0;
              }
              else
                return res -1005;
            }
            else
              return res*(-1)-1001;
          }
          else
            return res -1005;
        }
        else
          return res*(-1)-1001;
      break;
      case High:
        res = sysSetVariableInt(namespace,"RelayGnd",0);
        if (res == 0) {
          res = testWaitForTimeout(200);
          if (res == 0) {
            res = sysSetVariableInt(namespace,"RelayVBatt",1);
            if (res == 0) {
              res = testWaitForTimeout(200);
              if (res == 0) {
                testStep("VT outputs digital level for product input pin","For pin %s:Module%d channel%d generates high digital level.",pinName,vt2516CfgInfo[0],vt2516CfgInfo[1]);
                return 0;
              }
              else
                return res - 1005;
            }
            else
              return res*(-1)-1001;
          }
          else
            return res - 1005;
        }
        else
          return res*(-1)-1001;
      break;
      case Floating:
        res = sysSetVariableInt(namespace,"RelayGnd",0);
        if (res == 0) {
          res = testWaitForTimeout(200);
          if (res == 0) {
            res = sysSetVariableInt(namespace,"RelayVBatt",0);
            if (res == 0) {
              res = testWaitForTimeout(200);
              if (res == 0) {
                testStep("VT outputs digital level for product input pin","For pin %s:Module%d channel%d is set to float.",pinName,vt2516CfgInfo[0],vt2516CfgInfo[1]);
                return 0;
              }
              else
                return res - 1005;
            }
            else
              return res*(-1)-1001;
          }
          else
            return res - 1005;
        }
        else
          return res*(-1)-1001;
      break;
      default:
        testStepFail("Error","Undefined digital level.");
        return -1008;
      break;
    }
  }
  else {
    testStepFail("Error","The value number in section:vt2516Cfg,key name:%s is %d, not equal to 2. Please check the paraCfg.ini file.",pinName,numOfValsReadIn);
    return -1001;
  }
}

export int chAOSet (char pinName[],float analogValue) {//pinName[] gets from key name in section vt2516Cfg
  char vt2516CfgInfo[2],namespace[100];
  int numOfValsReadIn,res;
  numOfValsReadIn = getCfgDataArray ("vt2516Cfg",pinName,vt2516CfgInfo);
  if (numOfValsReadIn == 2) {
    snprintf(namespace,elcount(namespace),"VTS::M%d_Ch%d",vt2516CfgInfo[0],vt2516CfgInfo[1]);
    res = vtsSetStimulationMode(namespace,0);//sysvar::VTS::M9_Ch5.SetStimulationMode(0);//stim mode inactive
    if (res == 0) {
      res = vtsSetCurveType(namespace,0);//sysvar::VTS::M9_Ch5.SetCurveType(0);//set curve type as constant
      if (res == 0) {
        res = vtsSetPWMVoltageHigh(namespace,analogValue);//sysvar::VTS::M9_Ch5.SetPWMVoltageHigh(random(6)+7);//set voltagelow 7-12
        if (res == 0) {
          res = sysSetVariableInt(namespace,"DigitalOutput",1);//@sysvar::VTS::M9_Ch5::DigitalOutput = 1;//output digital=1
          if (res == 0) {
            res = vtsSetStimulationMode(namespace,1);//sysvar::VTS::M9_Ch5.SetStimulationMode(1);//stim mode as voltage
            if (res == 0) {
              testStep("VT outputs analog value for product input pin","For pin %s:Module%d channel%d generates analog voltage: voltage = %3.1fV",pinName,vt2516CfgInfo[0],vt2516CfgInfo[1],analogValue);
              return 0;
            }
            else
              return res - 1001;
          }
          else 
            return res*(-1) - 1005;
        }
        else
          return res - 1001;
      }
      else
        return res - 1001;
    }
    else
      return res - 1001;
  }
  else {
    testStepFail("Error","The value number in section:vt2516Cfg,key name:%s is %d, not equal to 2. Please check the paraCfg.ini file.",pinName,numOfValsReadIn);
    return -1001;
  }
}

export int chRamVoltDOSet (char pinName[],enum prodInputStat state) {//pinName[] gets from key name in section vLevelCfg
  int randomValue,numOfValsReadIn,res;
  char vLevelCfgInfo[4];
  numOfValsReadIn = getCfgDataArray ("vLevelCfg",pinName,vLevelCfgInfo);
  if (numOfValsReadIn == 4) {
    if (state)
      randomValue = vLevelCfgInfo[2] + random(vLevelCfgInfo[3]);
    else
      randomValue = vLevelCfgInfo[0] + random(vLevelCfgInfo[1]);
    res = chAOSet(pinName,randomValue);
    return res;
  }
  else {
    testStepFail("Error","The value number in section:vLevelCfg,key name:%s is %d, not equal to 4. Please check the paraCfg.ini file.",pinName,numOfValsReadIn);
    return -1001;
  }
}

export int prodDIPinStatGet (char pinName[]) {
  char namespace[100],vt2516CfgInfo[2],vLevelCfgInfo[4];
  float avgVolt;
  int numOfValsReadIn;
  numOfValsReadIn = getCfgDataArray ("vt2516Cfg",pinName,vt2516CfgInfo);
  if (numOfValsReadIn == 2) {
    numOfValsReadIn = getCfgDataArray ("vLevelCfg",pinName,vLevelCfgInfo);
    if (numOfValsReadIn == 4) {
      snprintf(namespace,elcount(namespace),"VTS::M%d_Ch%d",vt2516CfgInfo[0],vt2516CfgInfo[1]);
      avgVolt = sysGetVariableFloat(namespace,"Avg");
      if ((avgVolt >= vLevelCfgInfo[0] - 0.5) && (avgVolt < vLevelCfgInfo[0] + vLevelCfgInfo[1])) {
        testStep("DI PIN Level measurement","PIN %s: Input voltage level is %4.2fV, at inactive state.",pinName,avgVolt);
        return (int)Inactive;
      }
      else if ((avgVolt >= vLevelCfgInfo[2] - 0.5) && (avgVolt < vLevelCfgInfo[2] + vLevelCfgInfo[3])) {
        testStep("DI PIN Level measurement","PIN %s: Input voltage level is %4.2fV, at active state.",pinName,avgVolt);
        return (int)Active;
      }
      else {
        testStep("DI PIN Level measurement","PIN %s: Input voltage level is %4.2fV, at no definition state.",pinName,avgVolt);
        return -1002;//No definition.
      }
    }
    else {
      testStepFail("Error","The value number in section:vLevelCfg,key name:%s is %d, not equal to 4. Please check the paraCfg.ini file.",pinName,numOfValsReadIn);
      return -1001;
    }
  }
  else {
    testStepFail("Error","The value number in section:vt2516Cfg,key name:%s is %d, not equal to 2. Please check the paraCfg.ini file.",pinName,numOfValsReadIn);
    return -1001;
  }
}

export int chPwmOutSet (char pinName[],char productPwmInMode[]) {//pinName[] gets from key name in section vt2516Cfg,productPwmInMode[]gets from key name in section pwmWaveCfg
  char namespace[100],vt2516CfgInfo[2],pwmWaveCfgInfo[5],duty;
  int numOfValsReadIn,res;
  numOfValsReadIn = getCfgDataArray ("vt2516Cfg",pinName,vt2516CfgInfo);
  if (numOfValsReadIn == 2) {
    numOfValsReadIn = getCfgDataArray ("pwmWaveCfg",productPwmInMode,pwmWaveCfgInfo);
    testStep("","pwmWaveCfg num = %d",numOfValsReadIn);
    if (numOfValsReadIn == 5) {
      duty = pwmWaveCfgInfo[3]+random(pwmWaveCfgInfo[4]);
      snprintf(namespace,elCount(namespace),"VTS::M%d_Ch%d",vt2516CfgInfo[0],vt2516CfgInfo[1]);
      res = vtsSetStimulationMode(namespace,0);//sysvar::VTS::M9_Ch3.SetStimulationMode(0);//stim mode inactive
      if (res != 0) 
        return res - 1001;
      else {
        res = vtsSetPWMVoltageLow(namespace,pwmWaveCfgInfo[1]);//sysvar::VTS::M9_Ch3.SetPWMVoltageLow(random(3)+1);//set voltagelow 1-3
        if (res != 0)
          return res - 1001;
        else {
          res = vtsSetPWMVoltageHigh(namespace,pwmWaveCfgInfo[2]);//sysvar::VTS::M9_Ch3.SetPWMVoltageHigh(12);//set voltagehigh 7-15 
          if (res != 0)
            return res - 1001;
          else {
            res = vtsSetCurveType(namespace,1);//sysvar::VTS::M9_Ch3.SetCurveType(1);//set curve type as PWM
            if (res != 0)
              return res - 1001;
            else {
              res = sysSetVariableFloat(namespace,"PWMOutputFreq",pwmWaveCfgInfo[0]); //@sysvar::VTS::M9_Ch3::PWMOutputFreq = 100;//PWM output Freq =100Hz
              if (res != 0) 
                return res*(-1)-1005;
              else {
                res = sysSetVariableFloat(namespace,"PWMOutputDC",duty);//@sysvar::VTS::M9_Ch3::PWMOutputDC = 10;
                if (res != 0 ) 
                  return res*(-1)-1005;
                else {
                  res = vtsSetStimulationMode(namespace,1);//sysvar::VTS::M9_Ch3.SetStimulationMode(1);//stim mode as voltage
                  if (res != 0)
                    return res - 1001;
                  else {
                    res = vtsStartStimulation(namespace);//sysvar::VTS::M9_Ch3.StartStimulation();
                    if (res != 0)
                      return res - 1001;
                    else {
                      testStep("VT outputs PWM for product input pin","For pin %s:Module%d channel%d generates PWM:Highvolt=%dV,Lowvolt=%dV,Duty=%d%%,Freq=%dHz",pinName,vt2516CfgInfo[0],vt2516CfgInfo[1],pwmWaveCfgInfo[2],pwmWaveCfgInfo[1],duty,pwmWaveCfgInfo[0]);
                      return 0;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    else {
      testStepFail("Error","The value number in section:pwmWaveCfg,key name:%s is %d, not equal to 5. Please check the paraCfg.ini file.",productPwmInMode,numOfValsReadIn);
      return -1001;
    }
  }
  else {
    testStepFail("Error","The value number in section:vt2516Cfg,key name:%s is %d, not equal to 2. Please check the paraCfg.ini file.",pinName,numOfValsReadIn);
    return -1001;
  }
}

export int chLoadConnectStatSet (char pinName[],enum connectStat stat) {//pinName[] gets from key name in section vt2516Cfg
  char vt2516CfgInfo[2],namespace[100],connectState[2][11] = {"disconnect","connect"};
  int numOfValsReadIn,res;
  numOfValsReadIn = getCfgDataArray ("vt2516Cfg",pinName,vt2516CfgInfo);
  if (numOfValsReadIn == 2) {
    snprintf(namespace,elcount(namespace),"VTS::M%d_Ch%d",vt2516CfgInfo[0],vt2516CfgInfo[1]);
    res = sysSetVariableInt(namespace,"RelayOrgComponent",stat);
    if (res != 0)
      return -1001 - res;
    else {
      res = wait(200);
      if (res != 0)
        return res-5;
      else {
        testStep("VT channel's load connection status","For pin %s:Module%d channel%d %s with load.",pinName,vt2516CfgInfo[0],vt2516CfgInfo[1],connectState[stat]);
        return 0;
      }
    }
  }
  else {
    testStepFail("Error","The value number in section:vt2516Cfg,key name:%s is %d, not equal to 2. Please check the paraCfg.ini file.",pinName,numOfValsReadIn);
    return -1001;
  }
}

/************************Product function related******************************/
export int prodOperWithPinStatImpOnSpecSigChk (char operationMode[]) {//operationMode[] gets from key name in section: btnPrsImpOnSpecSigCfg
  int respOk,paraNum,i,demRes,revPinStat,res,resWait;
  char heading[200],cfgStrArray[101][100];
  paraNum = getCfgStrArray("prodOperWithPinStatImpOnSpecSigCfg",operationMode,cfgStrArray);
  //testStep("","paraNum=%d,%s,%s,%s,%s,%s,%s",paraNum,cfgStrArray[0],cfgStrArray[1],cfgStrArray[4],cfgStrArray[5],cfgStrArray[6],cfgStrArray[9]);
  res = 0;
  if (paraNum!=-1001)  {
    if (paraNum%5==0) {//paraNum+1==real para number,but first parameter only shows once.
      revPinStat = prodDIPinStatGet(cfgStrArray[0]);
      if (revPinStat >= 0) { 
        for (i=0;(i<paraNum/5 && (res<-10000 || res>=0));i++) {
          if (strncmp(operationMode,"IDLE",4)!=0) {
            strncpy(heading,"Operate product ",strlen("Operate product ")+1);
            strncat(heading,operationMode,200);
            strncat(heading," for checking the signal ",200);
            strncat(heading,cfgStrArray[5*i+1],200);
            testValidateTesterConfirmation(heading,"",1);
            resWait = wait(atol(cfgStrArray[5*i+3]));
          }
          if (resWait != 0)
            res = resWait - 3;
          else {
            demRes = atol(cfgStrArray[5*i+4])*revPinStat +atol(cfgStrArray[5*i+5]);
            respOk = (getSignal(cfgStrArray[5*i+1])==atodbl(cfgStrArray[5*i+2]));
            respOk = (respOk == demRes);
            if (respOk) {
              if (demRes)
                testStepPass("Operate product and check signal update","Product operate:%s,the value of signal:%s updates to %1.0f within %dms.",operationMode,cfgStrArray[5*i+1],getSignal(cfgStrArray[5*i+1]),atol(cfgStrArray[5*i+3]));
              else
                testStepPass("Operate product and check signal update","Product operate:%s,the value of signal:%s keeps %1.0f during %dms, not update to %d",operationMode,cfgStrArray[5*i+1],getSignal(cfgStrArray[5*i+1]),atol(cfgStrArray[5*i+3]),atol(cfgStrArray[5*i+2]));
            }
            else {
              if (demRes) {
                testStepFail("Operate product and check signal update","Product operate:%s,the value of signal:%s is %1.0f, not updates to %d during %dms.",operationMode,cfgStrArray[5*i+1],getSignal(cfgStrArray[5*i+1]),atol(cfgStrArray[5*i+2]),atol(cfgStrArray[5*i+3]));
                res = -10001;
              }
              else {
                testStepFail("Operate product and check signal update","Product operate:%s,the value of signal:%s is %1.0f, not keeps the old value during %dms.",operationMode,cfgStrArray[5*i+1],getSignal(cfgStrArray[5*i+1]),atol(cfgStrArray[5*i+3]));  
                res = -10002;
              }
            }
          }
        }
        return res;
      }
      else 
        return revPinStat-1;
    }
    else {
      testStepFail("Error","Data number in key %s is not right.",operationMode);
      return -1002;
    }
  }
  else
    return -1001;
} 

export int prodOperWithPinStatImpOnSpecPwmChk (char operationMode[]) {//operationMode[] gets from key name in section: btnPrsImpOnSpecPwmCfg
  int paraNum,i,impFactVal,res,resChk;
  char heading[200],cfgStrArray[61][100];//assume pwm check number will not larger than 10 at a time
  paraNum = getCfgStrArray("prodOperWithPinStatImpOnSpecPwmCfg",operationMode,cfgStrArray);
  res = 0;
  //testStep("","paraNum = %d,%s,%s,%s,%s",paraNum,cfgStrArray[0],cfgStrArray[5],cfgStrArray[6],cfgStrArray[11]);
  if (paraNum!=-1001) {
    if (paraNum%6==0) {//paraNum+1==real para number,but first parameter only shows once.
      impFactVal = prodDIPinStatGet(cfgStrArray[0]);
      if (impFactVal >= 0) {
        for (i=0;(i<paraNum/6 && (res<-10000 || res==0));i++) {
          if (strncmp(operationMode,"IDLE",4)!=0) {
            strncpy(heading,"Operate product ",strlen("Operate product ")+1);
            strncat(heading,operationMode,200);
            strncat(heading," for checking the PIN:",200);
            strncat(heading,cfgStrArray[6*i+1],200);
            testValidateTesterConfirmation(heading,"",1);
          }
          resChk = prodPwmOutChk(cfgStrArray[i*6+1],atol(cfgStrArray[i*6+2])*impFactVal+atol(cfgStrArray[i*6+3]),atol(cfgStrArray[i*6+4])*impFactVal+atol(cfgStrArray[i*6+5]),atol(cfgStrArray[i*6+6]));
          if (resChk == -1001)
            res = -1002;
          else if (resChk != 0)
            res = resChk;
        }
        return res;
      }
      else 
        return impFactVal-1;
    }
    else {
      testStepFail("Error","Data number in key %s is not right.",operationMode);
      return -1002;
    }
  }
  else
    return -1001;
}

export int prodOperWithSigStatImpOnSpecPwmChk (char operationMode[]) {//operationMode[] gets from key name in section: btnPrsImpOnSpecPwmCfg
  int paraNum,i,res,resChk;
  float impFactVal;
  char heading[200],cfgStrArray[61][100];//assume pwm check number will not larger than 10 at a time
  paraNum = getCfgStrArray("prodOperWithSigStatImpOnSpecPwmCfg",operationMode,cfgStrArray);
  //testStep("","paraNum = %d,%s,%s,%s,%s",paraNum,cfgStrArray[0],cfgStrArray[5],cfgStrArray[6],cfgStrArray[11]);
  res = 0;
  if (paraNum!=-1001) {
    if (paraNum%6==0) {//paraNum+1==real para number,but first parameter only shows once.
      impFactVal = getSignal(cfgStrArray[0]);
      if ((impFactVal == 1.0) || (impFactVal == 0)){
        for (i=0;(i<paraNum/6 && (res<-10000 || res==0));i++) {
          if (strncmp(operationMode,"IDLE",4)!=0) {
            strncpy(heading,"Operate product ",strlen("Operate product ")+1);
            strncat(heading,operationMode,200);
            strncat(heading," for checking the PIN:",200);
            strncat(heading,cfgStrArray[6*i+1],200);
            testValidateTesterConfirmation(heading,"",1);
          }
          resChk = prodPwmOutChk(cfgStrArray[i*6+1],atol(cfgStrArray[i*6+2])*impFactVal+atol(cfgStrArray[i*6+3]),atol(cfgStrArray[i*6+4])*impFactVal+atol(cfgStrArray[i*6+5]),atol(cfgStrArray[i*6+6])); 
          if (resChk == -1001)
            res = -1002;
          else if (resChk != 0)
            res = resChk;
        }
        return res;
      }
      else {
        testStepFail("Error","The value of signal:%s is %4.1f, not a simple 0,1 value. So this function is not adaptable for this situation.",cfgStrArray[0],impFactVal);
        return -1003;
      }
    }
    else {
      testStepFail("Error","Data number in key %s is not right.",operationMode);
      return -1002;
    }
  }
  else
    return -1001;
}

export int sigDirTwoStatInSet (char pinName[], enum determiningFactor dFct, enum prodInputStat state) {
  char cfgStrArray[4][100];
  int paraNum,res;
  paraNum = getCfgStrArray("sigDirTwoStatInCfg",pinName,cfgStrArray);
  if (paraNum != -1001) {
    if (!dFct) {//determinedBySignal
      res = testEnableMsg(cfgStrArray[0]);
      if (res != 0)
        return res-1001;
      else {
        if (state) 
          res = signalSetting (cfgStrArray[1],atodbl(cfgStrArray[3]),1);
        else 
          res = signalSetting (cfgStrArray[1],atodbl(cfgStrArray[2]),1);
        if (res != 0)
          res = res - 2;
        else {
          res = chRamVoltDOSet(pinName,(enum prodInputStat)(random(2))); 
          if (res != 0)
            res = res - 4;
        }
        return res;
      }
    }    
    else {//determinedByHardware
      res = testDisableMsg(cfgStrArray[0]);
      if (res != 0)
        return res-1001;
      else {
        res = wait(150);
        if (res != 0)
          return res - 13;
        else {
          if (state)
            res = chRamVoltDOSet(pinName,Active);
          else 
            res = chRamVoltDOSet(pinName,Inactive);
          if (res != 0)
            res = res - 4;
          return res;
        }
      }
    }
  }
  else
    return -1001;
}

export int sigDirMulStatInSet (char specStat[], enum determiningFactor dFct) {
  char cfgStrArray[5][100];
  int paraNum,res;
  paraNum = getCfgStrArray("sigDirMulStatInCfg",specStat,cfgStrArray);
  if (paraNum!=-1001) {
    if (!dFct) {//decided by CAN signal
      res = testEnableMsg(cfgStrArray[0]);
      if (res != 0)
        return res - 1001;
      else {
        res = signalSetting(cfgStrArray[1],atol(cfgStrArray[2]),atol(cfgStrArray[3]));
        if (res != 0)
          return res - 2;
        else {
          res = chPwmOutSet(cfgStrArray[4],"ANY");//PWM INPUT whatever
          if (res != 0)
            return res - 4;
          else
            return 0;
        }
      }
    }
    else {//decided by PWM input
      res = chPwmOutSet(cfgStrArray[4],specStat);
      if (res != 0)
        return res - 4;
      else {
        res = testDisableMsg(cfgStrArray[0]);
        if (res != 0)
          return res - 1001;
        else
          return 0;
      }
    }
  }
  else
    return -1001;
}

export int specStatImpOnSigChk (char specStat[]) {
  int returnStatus,paraNum,res;
  char impactSigInfo[3][100];
  paraNum = getCfgStrArray ("specStatImpOnSigCfg",specStat,impactSigInfo);
  if (paraNum!=-1001) {
    res = wait(atol(impactSigInfo[2]));
    if (res != 0)
      return res - 1;
    else {
      if (getSignal(impactSigInfo[0])==atodbl(impactSigInfo[1])) {
        testStepPass("check signal status","Correct response: %s = %1.0f within %dms.",impactSigInfo[0],getSignal(impactSigInfo[0]),atol(impactSigInfo[2]));
        return 0;
      }
      else {
        testStepFail("check signal status","Incorrect response: %s = %1.0f, updating to %1.0f didn't completed within %dms.",impactSigInfo[0],getSignal(impactSigInfo[0]),atodbl(impactSigInfo[1]),atol(impactSigInfo[2]));
        return -10001;
      }
    }
  }
  else
    return -1001;
}

export void stateMachine (char stateMachineSection[],int routeNum[],char paraPick[][][]) {//char paraPick[var num][2][100],paraPick[var num][0]=variant name,paraPick[var num][1]=var string value
  int i,j,n,m,funcNum,findParaValBool,errBool,paraNum[30],cmp,recAnalyzeDataByteNum,res;
  byte recMsg[100];
  char step[100],loopNum[5],cfgFuncArray[10][50][200],nameSpace[20];
  n = 1;
  m = 0;
  i = 0; 
  j = 0;
  errBool=0;
  res = 0;
  do {
    findParaValBool = 0;
    strncpy(step, "step", elCount(step));
    ltoa(i+1,loopNum,10);
    //testStep("","%s",loopNum);
    strncat(step,loopNum,24);
    funcNum = getCfgFuncArray(stateMachineSection,step,cfgFuncArray,paraNum);
    //testStep("","%s,%s,%s,%s,routeNum[i]=%d,paraNum=%d,paraPick_count=%d",cfgFuncArray[0][0],cfgFuncArray[0][1],cfgFuncArray[1][0],cfgFuncArray[1][1],routeNum[i],paraNum[routeNum[i]],elcount(paraPick));
    if (funcNum!=-1001) {
      if ((funcNum >= routeNum[i])&&(routeNum[i] >= 0)) {
        if (paraPick[0][0][0]!='\0'){
          for (n=1;n<=paraNum[routeNum[i]];n++) {//@n=0,string=funcName;
            if (cfgFuncArray[routeNum[i]][n][0] == '*') {
              for (m=0;m<elcount(paraPick);m++) {
                if (strncmp(paraPick[m][0],cfgFuncArray[routeNum[i]][n],1,100)==0) {
                  strncpy(cfgFuncArray[routeNum[i]][n],paraPick[m][1],elCount(paraPick[m][1]));
                  m = elCount(paraPick)-1;//stop for loop;
                  findParaValBool = 1;
                }
              }
              if (!findParaValBool) {
                errBool = 1;
                testStepFail("Error","At step %s, don't find any defined argument to substitute for parameter %s in function %s.",loopNum,cfgFuncArray[routeNum[i]][n],cfgFuncArray[routeNum[i]][0]);
              }
            }
          }
        }
        for (j=0;(j<elcount(func))&&(!errBool);j++) {
          cmp = strncmp(cfgFuncArray[routeNum[i]][0],func[j],elCount(cfgFuncArray[routeNum[i]][0]));
          //testStep("","func=%s,pick=%s,cmp=%d",cfgFuncArray[routeNum[i]][0],func[j],cmp);
          if (cmp == 0) {
            switch(j) {
              case 0:
                res = testValidateTesterConfirmation (cfgFuncArray[routeNum[i]][1],"",1);
                if (res < 0)
                  res = res - 1000;
              break;
              case 1:
                res = signalSetting (cfgFuncArray[routeNum[i]][1], atodbl(cfgFuncArray[routeNum[i]][2]),atol(cfgFuncArray[routeNum[i]][3]));
              break;
              case 2:
                res = signalContSetting (cfgFuncArray[routeNum[i]][1], atodbl(cfgFuncArray[routeNum[i]][2]), atol(cfgFuncArray[routeNum[i]][3]), atol(cfgFuncArray[routeNum[i]][4]));
              break;
              case 3:
                //testStep("",cfgFuncArray[routeNum[i]][1]);
                res = testEnableMsg(cfgFuncArray[routeNum[i]][1]);
                if (res < 0)
                  res = res - 1000;
              break;
              case 4:
                res = testDisableMsg(cfgFuncArray[routeNum[i]][1]);
                if (res < 0)
                  res = res - 1000;
              break;
              case 5:
                res = linActivateSlot(atol(cfgFuncArray[routeNum[i]][1]),atol(cfgFuncArray[routeNum[i]][2]));
                if (res == 0)
                  res = -1001;
                else
                  res = abs(res);
              break;
              case 6:
                res = linDeactivateSlot(atol(cfgFuncArray[routeNum[i]][1]),atol(cfgFuncArray[routeNum[i]][2]));
                if (res == 0)
                  res = -1001;
                else
                  res = abs(res);
              break;
              case 7:
                recAnalyzeDataByteNum = sendCanUdsDiagChkResp (cfgFuncArray[routeNum[i]][1],recMsg);
                res = recAnalyzeDataByteNum;
              break;
              case 8:
                recAnalyzeDataByteNum = sendCanKostiaDiagChkResp (cfgFuncArray[routeNum[i]][1],recMsg);
                res = recAnalyzeDataByteNum;
              break;
              case 9:
                recAnalyzeDataByteNum = sendLinUdsDiagChkResp (cfgFuncArray[routeNum[i]][1],recMsg);
                res = recAnalyzeDataByteNum;
              break;
              case 10:
                recAnalyzeDataByteNum = sendLinKostiaDiagChkResp (cfgFuncArray[routeNum[i]][1],recMsg);
                res = recAnalyzeDataByteNum;
              break;
              case 11:
                //testStep("validation","%s,%s",cfgFuncArray[routeNum[i]][1]);
                res = wait(atol(cfgFuncArray[routeNum[i]][1]));
              break;
              case 12:
                res = decodeAsciiFromRecDiag (recMsg,recAnalyzeDataByteNum,atol(cfgFuncArray[routeNum[i]][1]),atol(cfgFuncArray[routeNum[i]][2]),cfgFuncArray[routeNum[i]][3]);
              break;
              case 13:
                res = vtSysPwrSupInit (cfgFuncArray[routeNum[i]][1]);
              break;
              case 14:
                res = vtSysWithExPwrSupInit (cfgFuncArray[routeNum[i]][1]);
              break;
              case 15:
                res = vtSysPwrSupVoltSet (cfgFuncArray[routeNum[i]][1], atodbl(cfgFuncArray[routeNum[i]][2]));
              break;
              case 16:
                res = vtSysExPwrSupSet (cfgFuncArray[routeNum[i]][1], atodbl(cfgFuncArray[routeNum[i]][2]), atodbl(cfgFuncArray[routeNum[i]][3]), atol(cfgFuncArray[routeNum[i]][4])); 
              break;
              case 17:
                res = vtSysPwrSupVoltGet (cfgFuncArray[routeNum[i]][1], atodbl(cfgFuncArray[routeNum[i]][2]), atodbl(cfgFuncArray[routeNum[i]][3]));
              break;
              case 18:
                res = vtSysPwrSupCurrGet (cfgFuncArray[routeNum[i]][1],atodbl(cfgFuncArray[routeNum[i]][2]),atodbl(cfgFuncArray[routeNum[i]][3]),(enum vt7001MeasureRange)(atol(cfgFuncArray[routeNum[i]][4])),(enum currentUnit)(atol(cfgFuncArray[routeNum[i]][5])));
              break;
              case 19:
                snprintf(nameSpace,elCount(nameSpace),"VTS::M%s_VT2516",cfgFuncArray[routeNum[i]][1]);
                res = vtsSetThreshold1_8(nameSpace,atodbl(cfgFuncArray[routeNum[i]][2]));//vtsSetThreshold1_8("VTS::M9_VT2516",1.1);
                if (res < 0)
                  res = res - 1000;
              break;
              case 20:
                snprintf(nameSpace,elCount(nameSpace),"VTS::M%s_VT2516",cfgFuncArray[routeNum[i]][1]);
                res = vtsSetThreshold9_16(nameSpace,atodbl(cfgFuncArray[routeNum[i]][2]));//vtsSetThreshold1_8("VTS::M9_VT2516",1.1);
                if (res < 0)
                  res = res - 1000;
              break;  
              case 21:
                res = prodPwmOutChk (cfgFuncArray[routeNum[i]][1],atodbl(cfgFuncArray[routeNum[i]][2]),atodbl(cfgFuncArray[routeNum[i]][3]),atol(cfgFuncArray[routeNum[i]][4]));
              break;
              case 22:
                res = prodPwmOutRisingEdgeMeas (cfgFuncArray[routeNum[i]][1]);
              break;
              case 23:
                res = prodPwmOutKeepTimeMeas (cfgFuncArray[routeNum[i]][1]);
              break;
              case 24:
                res = prodPwmOutFallingEdgeMeas (cfgFuncArray[routeNum[i]][1]);
              break;
              case 25:
                res = prodPwmOutRiseFallCurveMeas (cfgFuncArray[routeNum[i]][1]);
              break;
              case 26:
                res = chFixVoltDOSet (cfgFuncArray[routeNum[i]][1],(enum digitalLevel)(atol(cfgFuncArray[routeNum[i]][2])));
              break;
              case 27:
                res = chAOSet (cfgFuncArray[routeNum[i]][1],atodbl(cfgFuncArray[routeNum[i]][2])); 
              break;
              case 28:
                res = chRamVoltDOSet (cfgFuncArray[routeNum[i]][1],(enum prodInputStat)(atol(cfgFuncArray[routeNum[i]][2])));
              break;
              case 29:
                res = prodDIPinStatGet (cfgFuncArray[routeNum[i]][1]);
              break;
              case 30:
                res = chPwmOutSet (cfgFuncArray[routeNum[i]][1],cfgFuncArray[routeNum[i]][2]);
              break;
              case 31:
                res = chLoadConnectStatSet (cfgFuncArray[routeNum[i]][1], (enum connectStat)(atol(cfgFuncArray[routeNum[i]][2])));
              break;
              case 32:
                //testStep("validation","%s,%s",cfgFuncArray[routeNum[i]][1], cfgFuncArray[routeNum[i]][2]);
                res = prodOperWithPinStatImpOnSpecSigChk (cfgFuncArray[routeNum[i]][1]);
              break;
              case 33:
                //testStep("validation","%s,%s",cfgFuncArray[routeNum[i]][1], cfgFuncArray[routeNum[i]][2]);
                res = prodOperWithPinStatImpOnSpecPwmChk (cfgFuncArray[routeNum[i]][1]);
              break;
              case 34:
                res = prodOperWithSigStatImpOnSpecPwmChk (cfgFuncArray[routeNum[i]][1]);
              break;
              case 35:
                res = sigDirTwoStatInSet (cfgFuncArray[routeNum[i]][1], (enum determiningFactor)(atol(cfgFuncArray[routeNum[i]][2])), (enum prodInputStat)(atol(cfgFuncArray[routeNum[i]][3])));
              break;
              case 36:
                res = sigDirMulStatInSet (cfgFuncArray[routeNum[i]][1], (enum determiningFactor)(atol(cfgFuncArray[routeNum[i]][2])));
              break;
              case 37:
                res = specStatImpOnSigChk (cfgFuncArray[routeNum[i]][1]);
              break;
            }
            //testStep("Res","Res = %d.",res);
            if ((res > -10001) && (res < -1000))
              testStepFail("Error","At step %s, call function:%s error, error code = %d. Test sequence stop running. Please fix it then run the test sequence again.",loopNum,func[j],res);
            else if (res >= 0)
              testStepPass("Call function","At step %s, call function:%s success, function return value = %d.",loopNum,func[j],res);
            else
              testStepFail("Failure","At step %s, call function:%s has a failure, error code = %d.",loopNum,func[j],res);
            j = elCount(func)-1;
          }
          else {//cmp!=0
            if (j == (elCount(func)-1)) {
              testStepFail("Error","At step %s, function:%s in testStepCfg.ini file can't be found in the library. Test sequence stop running. Please check the function name, or add it into the library.",loopNum,cfgFuncArray[routeNum[i]][0]); 
              errBool = 1;
            }
          }
        }
        i++;
      }  
      else {
        errBool = 1;
        testStepFail("Error","At step %s, route number(=%d) > funcNum(=%d) or < 0,program can't pick up the right function. Test sequence stop running.",loopNum,routeNum[i],funcNum);
      }
    }
    else {//The loop will quit when one step(not exist in iniFile) not found in the iniFile. Not suitable for the nonexist step report a failure just for quiting the loop.
      if (i==0)
        testStepFail("Error","Don't find the key: %s in section: %s at testStepCfg.ini file. Test sequence stop running. Please check the section and key's name.",step,stateMachineSection);
    }
  }while((funcNum!=-1001)&&(!errBool)&&((res>=0)||(res<=-10001)));//exit loop if step not found or error occured.
  //testStep("","loop is over");
  for (i=0;i<elcount(routeNum);i++)
    routeNum[i] = 0;//restore routeNum
}